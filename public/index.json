[{"categories":["linux"],"content":"介绍 虽然我个人是计算机的科班毕业生，由于在学习操作系统的课程中并没有很好的代码实践，以至于到现在已经完全忘记了操作系统课程到内容。再加上在背各种“八股文”的过程中涉及到很多的底层的操作系统的知识，所以打算系统的学习下 mit 6.S081 课程。该课程的重点就是课后的实验（lab）。在做实验之前需要准备编程的环境，所以这篇文章记录的就是在 mac 下搭建 6.S081 课程的前置环境。 ","date":"2021-09-07","objectID":"/2021_9_7_mac-%E4%B8%8B-6.s081-%E7%9A%84%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:1:0","tags":["公开课"],"title":"Mac 下 6.S081 的环境搭建","uri":"/2021_9_7_mac-%E4%B8%8B-6.s081-%E7%9A%84%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["linux"],"content":"环境搭建 MacOS 下需要事先准备好 xcode 和 homebrew，我的系统版本是11.5.2。 homebrew 是 mac 的必备软件，所以它的安装过程就省略了 xcode 安装：xcode-select --install 实验环境主要包括三个部分： RISC-V工具链： 包括一系列交叉编译的工具，用于把源码编译成机器码，如gcc，binutils，glibc等 QEMU模拟器： 用于在我们机器上(X86)模拟RISC-V架构的CPU xv6源码： xv6操作系统源码 ","date":"2021-09-07","objectID":"/2021_9_7_mac-%E4%B8%8B-6.s081-%E7%9A%84%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:2:0","tags":["公开课"],"title":"Mac 下 6.S081 的环境搭建","uri":"/2021_9_7_mac-%E4%B8%8B-6.s081-%E7%9A%84%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["linux"],"content":"RISC-V toolchain $ brew tap riscv/riscv $ brew install riscv-tools 上面的安装好后把 riscv 加入到 mac 的环境变量中 PATH=$PATH:/usr/local/opt/riscv-gnu-toolchain/bin ","date":"2021-09-07","objectID":"/2021_9_7_mac-%E4%B8%8B-6.s081-%E7%9A%84%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:2:1","tags":["公开课"],"title":"Mac 下 6.S081 的环境搭建","uri":"/2021_9_7_mac-%E4%B8%8B-6.s081-%E7%9A%84%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["linux"],"content":"QEMU 模拟器 如果你直接按照官方的方式使用 homebrew 安装 qemu，安装好的 qemu 版本肯定大于 5.1，而 xv6 在高版本的 qemu 下编译有 bug 。所以我们只能手动的下载源码，编译 5.1 版本的 qemu # 卸载高版本 qemu brew uninstall qemu # 删除 qemu 的残留 rm -rf /usr/local/bin/vdeqemu # 下载源码 wget https://download.qemu.org/qemu-5.1.0-rc3.tar.xz tar xvf qemu-5.1.0-rc3.tar.xz cd qemu-5.1.0-rc3.tar.xz ./configure # 编译 make \u0026\u0026 make install ","date":"2021-09-07","objectID":"/2021_9_7_mac-%E4%B8%8B-6.s081-%E7%9A%84%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:2:2","tags":["公开课"],"title":"Mac 下 6.S081 的环境搭建","uri":"/2021_9_7_mac-%E4%B8%8B-6.s081-%E7%9A%84%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["linux"],"content":"vx6 下载 xv6 源码 git clone git://github.com/mit-pdos/xv6-riscv-fall19.git 编译 make qemu 退出 qemu 模拟器的方法：先按住 ctrl 和 a 松开后再按下 x ","date":"2021-09-07","objectID":"/2021_9_7_mac-%E4%B8%8B-6.s081-%E7%9A%84%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:2:3","tags":["公开课"],"title":"Mac 下 6.S081 的环境搭建","uri":"/2021_9_7_mac-%E4%B8%8B-6.s081-%E7%9A%84%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["linux"],"content":"参考 https://pdos.csail.mit.edu/6.828/2020/tools.html https://zhayujie.com/mit6828-env.html ","date":"2021-09-07","objectID":"/2021_9_7_mac-%E4%B8%8B-6.s081-%E7%9A%84%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:2:4","tags":["公开课"],"title":"Mac 下 6.S081 的环境搭建","uri":"/2021_9_7_mac-%E4%B8%8B-6.s081-%E7%9A%84%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["linux"],"content":"前置知识 ","date":"2021-07-16","objectID":"/2021.07.16_linux%E4%B8%AD%E7%9A%84socket%E5%92%8Cpiple%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B/:1:0","tags":["linux"],"title":"linux中的socket和piple文件类型","uri":"/2021.07.16_linux%E4%B8%AD%E7%9A%84socket%E5%92%8Cpiple%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B/"},{"categories":["linux"],"content":"$$ 和 $BASHPID 的用处和区别 $$ 和 $BASHPID 都是打印当前 bash 进程的进程编号，在下面的例子两者是没有区别的，输出结果相同 noel@noel:~$ echo $$ 2948 noel@noel:~$ echo $BASHPID 2948 但是在下面的例子下又不同 noel@noel:~$ { echo $$; read a;} | { cat; } 2948 noel@noel:~$ { echo $BASHPID; read a;} | { cat; } 3898 在 linux 中，管道(|)的两侧是通过两个子进程来分别执行的。$$ 在哪个进程中执行命令，该值就是哪个进程的PID。$BASHPID 就是当前进程的 PID 真实值（当前执行的命令的 PID）。 由于 { echo $BASHPID; read a;} | { cat; } 命令是由两个子进程来执行，所以 echo $BASHPID 打印的是子进程的 pid。 ","date":"2021-07-16","objectID":"/2021.07.16_linux%E4%B8%AD%E7%9A%84socket%E5%92%8Cpiple%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B/:1:1","tags":["linux"],"title":"linux中的socket和piple文件类型","uri":"/2021.07.16_linux%E4%B8%AD%E7%9A%84socket%E5%92%8Cpiple%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B/"},{"categories":["linux"],"content":"socket 文件类型 可以使用 exec 8\u003c\u003e /dev/tcp/www.baidu.com/80 在当前 bash 中打开一个 socket 文件类型 可以通过下面两种方式来验证 ","date":"2021-07-16","objectID":"/2021.07.16_linux%E4%B8%AD%E7%9A%84socket%E5%92%8Cpiple%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B/:2:0","tags":["linux"],"title":"linux中的socket和piple文件类型","uri":"/2021.07.16_linux%E4%B8%AD%E7%9A%84socket%E5%92%8Cpiple%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B/"},{"categories":["linux"],"content":"pipe 文件类型 linux 中的管道是进程间通信的一种方式，管道都是一端写入、另一端读取，它们是单方向数据传输的，它们的数据都是直接在内存中传输的。管道也是 linux 其中一种文件类型。 下面演示下如何观察 linux 下的 pipe 文件类型 查询下当前的 bash 的 pid noel@noel:~$ echo $$ 2948 执行下面的命令，会阻塞住 noel@noel:~$ { echo $BASHPID; read a; } | { cat ; echo $BASHPID; read y; } 6142 新开一个 bash 然后通过 pstree 命令查看之前 bash 的进程树 noel@noel:~$ pstree -p 2948 bash(2948)─┬─bash(6142) └─bash(6143)───cat(6144) 可以看到 2948 有两个子进程，分别是 6142 和 6143。我们通过 lsof 来观察下 上面的命令可以看出 6142 进程下有一个写入的 pipe ，6143 进程下有个读取的 pipe 通过 /prod/$pid/fd 下的文件也可以查看 ","date":"2021-07-16","objectID":"/2021.07.16_linux%E4%B8%AD%E7%9A%84socket%E5%92%8Cpiple%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B/:3:0","tags":["linux"],"title":"linux中的socket和piple文件类型","uri":"/2021.07.16_linux%E4%B8%AD%E7%9A%84socket%E5%92%8Cpiple%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B/"},{"categories":["linux"],"content":"在 linux 中手动的体验 overlay2 什么是UnionFS 联合文件系统（Union File System）可以把多个目录(也叫分支)内容联合挂载到同一个目录下，而目录的物理位置是分开的。linux 中 UnionFS 的实现有很多，docker 目前用的是 overlay2 上面这张图就是联合文件系统的一个示例：把 lower1，lower2，upper 三个文件的内容联合挂载到 merge 文件夹。要想知道overlay2是如何把这三个文件夹合并的，要先理解lowerdir,upperdir,work,merged 这四种文件夹 lowerdir ：表示较为底层的目录，修改联合挂载点不会影响到lowerdir。就是上图中的 lower1 ，lower2 文件夹 upperdir：表示较为上层的目录，修改联合挂载点会在upperdir同步修改。就是上图中的 upper 文件夹 merged：是 lowerdir 和 upperdir 合并后的联合挂载点。就是上图中蓝色的 merge 文件夹 workdir：用来存放挂载后的临时文件与间接文件。 手动的挂载 overlay2 首先下面的命令会创建这四种目录，并在这文件中创建了一些文件，用来观察 overlay 是如何联合挂载的 mkdir overlay-test cd overlay-test mkdir low1 mkdir low2 mkdir up mkdir merge mkdir work touch low1/a echo \"a in low1\" \u003e low1/a touch low1/b touch low2/a echo \"a in low2\" \u003e low2/a touch low2/c touch up/d 运行后的目录结构应该是下面这样的 然后执行 overlay 的挂载命令 sudo mount -t overlay overlay -o lowerdir=low1:low2,upperdir=up,workdir=work merge 执行后的目录结构： 从上图看出 merge 文件夹已经有了 low1，low2，up 三个文件夹的文件 由于 low1 和 low2 都有 a 文件，所以需要看下 merge 里的 a 文件来自于哪个文件夹 root@noel:~/overlay-test# cat merge/a a in low1 由于上面的命名中 lowerdir 文件夹挂载了两个文件，如果挂载了多个文件，左面的优先级高。所以 a 文件来自于 low1 文件夹 修改 merge 后的文件 在 merge 文件夹新增 new_file ，在 up 文件夹也新增了改文件 root@noel:~/overlay-test# touch merge/new_file root@noel:~/overlay-test# tree . ├── low1 │ ├── a │ └── b ├── low2 │ ├── a │ └── c ├── merge │ ├── a │ ├── b │ ├── c │ ├── d │ └── new_file ├── up │ ├── d │ └── new_file └── work └── work 6 directories, 12 files 修改 merge 下的 b 文件，low1 文件夹内的 b 文件没有改变 root@noel:~/overlay-test# echo \"bbbb\" \u003emerge/b root@noel:~/overlay-test# cat merge/b bbbb root@noel:~/overlay-test# cat low1/b root@noel:~/overlay-test# 修改 merge 下的 d 文件，up 文件夹内的 d 文件随之改变 root@noel:~/overlay-test# echo \"ddddd\" \u003e merge/d root@noel:~/overlay-test# cat merge/d ddddd root@noel:~/overlay-test# cat up/d ddddd root@noel:~/overlay-test# 总结 从上面的一些现象来看，lowerdir 就像是 docker 中的 image，low1 和 low2 就是 image 中 layer 的概念。upperdir 就是 docker 中的 container。 下图就是 dcoker 官网中的一个图片 ","date":"2021-02-26","objectID":"/2021.02.26_docker-%E4%B8%AD%E7%9A%84overlay-%E5%AD%98%E5%82%A8%E5%8E%9F%E7%90%86/:1:0","tags":["docker"],"title":"docker 中的 overlay 存储原理","uri":"/2021.02.26_docker-%E4%B8%AD%E7%9A%84overlay-%E5%AD%98%E5%82%A8%E5%8E%9F%E7%90%86/"},{"categories":["linux"],"content":"docker 中的 overlay ","date":"2021-02-26","objectID":"/2021.02.26_docker-%E4%B8%AD%E7%9A%84overlay-%E5%AD%98%E5%82%A8%E5%8E%9F%E7%90%86/:2:0","tags":["docker"],"title":"docker 中的 overlay 存储原理","uri":"/2021.02.26_docker-%E4%B8%AD%E7%9A%84overlay-%E5%AD%98%E5%82%A8%E5%8E%9F%E7%90%86/"},{"categories":["linux"],"content":"下载 image 使用docker pull ubuntu 来下载 image 来研究 root@noel:~# docker pull ubuntu Using default tag: latest latest: Pulling from library/ubuntu 83ee3a23efb7: Pull complete db98fc6f11f0: Pull complete f611acd52c6c: Pull complete Digest: sha256:703218c0465075f4425e58fac086e09e1de5c340b12976ab9eb8ad26615c3715 Status: Downloaded newer image for ubuntu:latest docker.io/library/ubuntu:latest root@noel:~# 上面命令可以看出我们下载了的 ubuntu 镜像有三层，那上面的例子来对比就是有 low1，low2，low3 三个文件夹 ","date":"2021-02-26","objectID":"/2021.02.26_docker-%E4%B8%AD%E7%9A%84overlay-%E5%AD%98%E5%82%A8%E5%8E%9F%E7%90%86/:2:1","tags":["docker"],"title":"docker 中的 overlay 存储原理","uri":"/2021.02.26_docker-%E4%B8%AD%E7%9A%84overlay-%E5%AD%98%E5%82%A8%E5%8E%9F%E7%90%86/"},{"categories":["linux"],"content":"观察 image 和 container 的文件结构 image docker 下载的镜像都在 /var/lib/docker/overlay2 进入该目录后看下目录结构 root@noel:/var/lib/docker/overlay2# tree -L 2 . ├── 18533d22086c0f91c14a11499d506f53452c92a0179ce20de5d8de21b084b05c │ ├── committed │ ├── diff │ └── link ├── 78e6965c4bca0f7a6da0d72a1dc361933e9635ceec89519625b03bd4253d73b9 │ ├── diff │ ├── link │ ├── lower │ └── work ├── 7979e6ce4b2f7675255db2aec3d01a1f545425652952802cae4e42b8e8d56d78 │ ├── committed │ ├── diff │ ├── link │ ├── lower │ └── work └── l ├── 6CZZH722UFGUBASNSUFY24SAVT -\u003e ../18533d22086c0f91c14a11499d506f53452c92a0179ce20de5d8de21b084b05c/diff ├── PJGLJKKB3IET6REXBDXWWZPJPB -\u003e ../7979e6ce4b2f7675255db2aec3d01a1f545425652952802cae4e42b8e8d56d78/diff └── UFLIZTAI4O6KBT4XSDYLFFRVIQ -\u003e ../78e6965c4bca0f7a6da0d72a1dc361933e9635ceec89519625b03bd4253d73b9/diff diff ：文件实际存放位置 lower：存储的是父 layer 的 id，如果没有该文件，说明该 layer 是根节点 link：存储的是该文件夹的 短id 和 l 文件夹内的软连接相符 container docker run -it ubuntu 启动容器后再观察文件的变化 root@noel:/var/lib/docker/overlay2# tree -L 2 . ├── 18533d22086c0f91c14a11499d506f53452c92a0179ce20de5d8de21b084b05c │ ├── committed │ ├── diff │ └── link ├── 78e6965c4bca0f7a6da0d72a1dc361933e9635ceec89519625b03bd4253d73b9 │ ├── committed │ ├── diff │ ├── link │ ├── lower │ └── work ├── 7979e6ce4b2f7675255db2aec3d01a1f545425652952802cae4e42b8e8d56d78 │ ├── committed │ ├── diff │ ├── link │ ├── lower │ └── work ├── bd9fd7613eb3a36398b0c9929740c7393c1e8e97208486a4d5e9b54658f54e68 │ ├── diff │ ├── link │ ├── lower │ ├── merged │ └── work ├── bd9fd7613eb3a36398b0c9929740c7393c1e8e97208486a4d5e9b54658f54e68-init │ ├── committed │ ├── diff │ ├── link │ ├── lower │ └── work └── l ├── 6CZZH722UFGUBASNSUFY24SAVT -\u003e ../18533d22086c0f91c14a11499d506f53452c92a0179ce20de5d8de21b084b05c/diff ├── PJGLJKKB3IET6REXBDXWWZPJPB -\u003e ../7979e6ce4b2f7675255db2aec3d01a1f545425652952802cae4e42b8e8d56d78/diff ├── SIVTPIQFVUBGEQPAQABNZKAO4Q -\u003e ../bd9fd7613eb3a36398b0c9929740c7393c1e8e97208486a4d5e9b54658f54e68/diff ├── UFLIZTAI4O6KBT4XSDYLFFRVIQ -\u003e ../78e6965c4bca0f7a6da0d72a1dc361933e9635ceec89519625b03bd4253d73b9/diff └── XWLNFDN6UKH5MVFD32HLGEH57U -\u003e ../bd9fd7613eb3a36398b0c9929740c7393c1e8e97208486a4d5e9b54658f54e68-init/diff 可以发现多了两个文件夹 bd9fd7613.....8f54e68 和 bd9fd7613.....8f54e68-init bd9fd7613.....8f54e68 就是 container 的工作目录 init 为结尾的文件夹属于 lowerdir 层。init 层是 docker 项目单独生成的一个内部层，专门用来存放 /etc/hosts、/etc/resolv.conf 等信息。需要这样一层的原因是，这些文件本来属于只读的系统镜像层的一部分，但是用户往往需要在启动容器时写入一些指定的值比如hostname，所以就需要在可读写层对它们进行修改。可是，这些修改往往只对当前的容器有效，我们并不希望执行 docker commit 时，把这些信息连同可读写层一起提交掉。所以，docker 做法是，在修改了这些文件之后，以一个单独的层挂载了出来。而用户执行 docker commit 只会提交可读写层，所以是不包含这些内容的。 这时运行 mount | grep docker 查看系统目前挂载了什么文件 overlay on /var/lib/docker/overlay2/bd9fd7613eb3a36398b0c9929740c7393c1e8e97208486a4d5e9b54658f54e68/merged type overlay ( rw,relatime, lowerdir= /var/lib/docker/overlay2/l/XWLNFDN6UKH5MVFD32HLGEH57U: /var/lib/docker/overlay2/l/UFLIZTAI4O6KBT4XSDYLFFRVIQ: /var/lib/docker/overlay2/l/PJGLJKKB3IET6REXBDXWWZPJPB: /var/lib/docker/overlay2/l/6CZZH722UFGUBASNSUFY24SAVT, upperdir=/var/lib/docker/overlay2/bd9fd7613eb3a36398b0c9929740c7393c1e8e97208486a4d5e9b54658f54e68/diff, workdir=/var/lib/docker/overlay2/bd9fd7613eb3a36398b0c9929740c7393c1e8e97208486a4d5e9b54658f54e68/work ) 可以看到 upperdir 在 bd9fd7613.....8f54e68/diff 目录 在容器内使用 touch inner_container.txt 新建一个文件，看看该文件在文件在宿主机的哪个文件夹下 root@noel:/var/lib/docker/overlay2# find ./ -name inner_container.txt ./bd9fd7613eb3a36398b0c9929740c7393c1e8e97208486a4d5e9b54658f54e68/diff/inner_container.txt ./bd9fd7613eb3a36398b0c9929740c7393c1e8e97208486a4d5e9b54658f54e68/merged/inner_container.txt 可以看到在容器内新增了一个文件，只会在宿主机的 upperdir 和 merged 做出修改 ","date":"2021-02-26","objectID":"/2021.02.26_docker-%E4%B8%AD%E7%9A%84overlay-%E5%AD%98%E5%82%A8%E5%8E%9F%E7%90%86/:2:2","tags":["docker"],"title":"docker 中的 overlay 存储原理","uri":"/2021.02.26_docker-%E4%B8%AD%E7%9A%84overlay-%E5%AD%98%E5%82%A8%E5%8E%9F%E7%90%86/"},{"categories":["linux"],"content":"参考 https://zhuanlan.zhihu.com/p/95590072、 https://blog.csdn.net/luckyapple1028/article/details/78075358 https://staight.github.io/2019/10/04/%E5%AE%B9%E5%99%A8%E5%AE%9E%E7%8E%B0-overlay2/ https://docs.docker.com/storage/storagedriver/overlayfs-driver/#how-the-overlay-driver-works ","date":"2021-02-26","objectID":"/2021.02.26_docker-%E4%B8%AD%E7%9A%84overlay-%E5%AD%98%E5%82%A8%E5%8E%9F%E7%90%86/:3:0","tags":["docker"],"title":"docker 中的 overlay 存储原理","uri":"/2021.02.26_docker-%E4%B8%AD%E7%9A%84overlay-%E5%AD%98%E5%82%A8%E5%8E%9F%E7%90%86/"},{"categories":["db"],"content":"问题 今天偶然发现 mysql 在比较字符时会忽略大小写，这让我非常意外。 比如 select 'a' = 'A' 这行运行的结果是 1也就是在 mysql 看来 a 和 A 是相等的 经过一番的查找原来是 mysql 的 collate 属性造成的 ","date":"2021-02-20","objectID":"/2021_02_20_mysql-%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E4%BF%AE%E6%94%B9-collate/:1:0","tags":["mysql"],"title":"mysql 如何查看，修改 collate","uri":"/2021_02_20_mysql-%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E4%BF%AE%E6%94%B9-collate/"},{"categories":["db"],"content":"collate 我们在创建数据库是一般都是直接 create database \u003cname\u003e 如果需要使用 utf8 字符集会在后面指定 database 的字符集create database \u003cname\u003e character set utf8mb4 但除了charset 属性还有collate 属性是可以设置（如下），collate 就是和大小写敏感有关 CREATE DATABASE \u003cname\u003e CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci; collate 的作用 对于mysql中那些字符类型的列，如VARCHAR，CHAR，TEXT类型的列，都需要有一个COLLATE类型来告知mysql如何对该列进行排序和比较。简而言之，COLLATE会影响到ORDER BY语句的顺序，会影响到WHERE条件中大于小于号筛选出来的结果，会影响DISTINCT、GROUP BY、HAVING语句的查询结果。另外，mysql建索引的时候，如果索引列是字符类型，也会影响索引创建，只不过这种影响我们感知不到。总之，凡是涉及到字符类型比较或排序的地方，都会和COLLATE有关。 collate 的后缀 collate 有三种后缀 _ci ： case insensitive 的缩写，即大小写无关。例如：utf8mb4_general_ci _cs ： case sensitive 的缩写 ，即大小写有关 _bin ：把字符看作二进制串，然后从最高位往最低位比对。所以很显然它是区分大小写的。例如 utf8mb4_bin 其他 在 mysql 5.7 中 utf8 编码的默认 collate 是 utf8mb4_general_ci show collation 可以查看 mysql 所有支持的 collate ","date":"2021-02-20","objectID":"/2021_02_20_mysql-%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E4%BF%AE%E6%94%B9-collate/:2:0","tags":["mysql"],"title":"mysql 如何查看，修改 collate","uri":"/2021_02_20_mysql-%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E4%BF%AE%E6%94%B9-collate/"},{"categories":["db"],"content":"查看 collate 从上面的信息 得出collate 是影响查询大小写敏感的关键，所以接下来肯定是想要看看目前的数据库，表的 collate 值是什么，是不是以 _ci 结尾 查询 database 的 collate SELECT SCHEMA_NAME 'database', DEFAULT_CHARACTER_SET_NAME 'charset', DEFAULT_COLLATION_NAME 'collation' FROM information_schema.SCHEMATA where SCHEMA_NAME = 'collate_test_db'; 结果： +-----------------+---------+--------------------+ | database | charset | collation | +-----------------+---------+--------------------+ | collate_test_db | utf8mb4 | utf8mb4_general_ci | +-----------------+---------+--------------------+ 查询表的 collate select TABLE_SCHEMA, TABLE_COLLATION from information_schema.TABLES where TABLE_NAME = 'collate_test_table' 结果： +-----------------+--------------------+ | TABLE_SCHEMA | TABLE_COLLATION | +-----------------+--------------------+ | collate_test_db | utf8mb4_general_ci | +-----------------+--------------------+ 查询列的 collate SHOW FULL COLUMNS FROM \u003ctable_name\u003e; ","date":"2021-02-20","objectID":"/2021_02_20_mysql-%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E4%BF%AE%E6%94%B9-collate/:3:0","tags":["mysql"],"title":"mysql 如何查看，修改 collate","uri":"/2021_02_20_mysql-%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E4%BF%AE%E6%94%B9-collate/"},{"categories":["db"],"content":"修改 collate 从上面看出的数据库和表都是 _ci 后缀的，所以下面就是把后缀改为 _bin database 层级的修改 ALTER DATABASE collate_test_db DEFAULT CHARACTER SET utf8mb4 COLLATE = utf8mb4_bin; 这只是修改了 database 的默认 collate ，不会对已经存在的表进行修改 table 层级的修改 ⚠️ 注意下面有两个 sql ：第一个 sql 只会修改 table 的默认 collate ，不会修改已经存在字段的 collate 。第二个 sql 不但会修改默认的 collate ，还会修改已存在的字段。所以推荐使用第二个 sql ALTER TABLE collate_test_table CHARACTER SET utf8mb4 COLLATE utf8mb4_bin; ALTER TABLE collate_test_table CONVERT TO CHARACTER SET utf8mb4 COLLATE utf8mb4_bin; 批量生成修改 collate 的sql 如果一个 database 内的 table 过多，一个个写 alter sql 太麻烦了，可以批量生成 SELECT CONCAT('ALTER TABLE `', TABLE_NAME, '` CONVERT TO CHARACTER SET utf8mb4 COLLATE utf8mb4_bin;') AS target_tables FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA = 'collate_test_db' AND TABLE_TYPE = 'BASE TABLE' 结果： +------------------------------------------------------------------------------------------+ | target_tables | +------------------------------------------------------------------------------------------+ | ALTER TABLE `collate_test_table` CONVERT TO CHARACTER SET utf8mb4 COLLATE utf8mb4_bin; | | ALTER TABLE `collate_test_table_1` CONVERT TO CHARACTER SET utf8mb4 COLLATE utf8mb4_bin; | | ALTER TABLE `collate_test_table_2` CONVERT TO CHARACTER SET utf8mb4 COLLATE utf8mb4_bin; | | ALTER TABLE `collate_test_table_3` CONVERT TO CHARACTER SET utf8mb4 COLLATE utf8mb4_bin; | | ALTER TABLE `collate_test_table_4` CONVERT TO CHARACTER SET utf8mb4 COLLATE utf8mb4_bin; | +------------------------------------------------------------------------------------------+ ","date":"2021-02-20","objectID":"/2021_02_20_mysql-%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E4%BF%AE%E6%94%B9-collate/:4:0","tags":["mysql"],"title":"mysql 如何查看，修改 collate","uri":"/2021_02_20_mysql-%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E4%BF%AE%E6%94%B9-collate/"},{"categories":["db"],"content":"参考 https://stackoverflow.com/questions/6115612/how-to-convert-an-entire-mysql-database-characterset-and-collation-to-utf-8 https://blog.csdn.net/ghosind/article/details/83692869 https://cloud.tencent.com/developer/article/1366841 ","date":"2021-02-20","objectID":"/2021_02_20_mysql-%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E4%BF%AE%E6%94%B9-collate/:5:0","tags":["mysql"],"title":"mysql 如何查看，修改 collate","uri":"/2021_02_20_mysql-%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E4%BF%AE%E6%94%B9-collate/"},{"categories":["db"],"content":"前言 今天有个业务是需要在某个表中新增一列。新增的列是个字典列，值的种类很少。一开始我想要使用 LowCardinality(String) 来存储，但有个同事说用uInt32 来存储。我的理由是看着直观，不用维护 int 的映射关系，他的理由是存储和查询的效率高。但是我从clickhouse 的官方文档中看到： The efficiency of using LowCardinality data type depends on data diversity. If a dictionary contains less than 10,000 distinct values, then ClickHouse mostly shows higher efficiency of data reading and storing. If a dictionary contains more than 100,000 distinct values, then ClickHouse can perform worse in comparison with using ordinary data types. 文档说数据的种类在十万以下时，效率很高，但不知道有多高。于是我打算 benchmark 测试下 LowCardinality(String) 和 uInt32 的性能差多少。 ","date":"2020-12-31","objectID":"/2020_12_31_clickhouse-%E4%B8%AD%E7%94%A8-int-%E7%B1%BB%E5%9E%8B%E4%BD%9C%E4%B8%BA%E5%AD%97%E5%85%B8%E7%9A%84%E6%95%88%E7%8E%87%E9%AB%98%E8%BF%98%E6%98%AF%E7%94%A8lowcardinalitystring/:1:0","tags":["clickhousue"],"title":"ClickHouse 中用 int 类型作为字典的效率高，还是用LowCardinality(String)","uri":"/2020_12_31_clickhouse-%E4%B8%AD%E7%94%A8-int-%E7%B1%BB%E5%9E%8B%E4%BD%9C%E4%B8%BA%E5%AD%97%E5%85%B8%E7%9A%84%E6%95%88%E7%8E%87%E9%AB%98%E8%BF%98%E6%98%AF%E7%94%A8lowcardinalitystring/"},{"categories":["db"],"content":"数据准备 ","date":"2020-12-31","objectID":"/2020_12_31_clickhouse-%E4%B8%AD%E7%94%A8-int-%E7%B1%BB%E5%9E%8B%E4%BD%9C%E4%B8%BA%E5%AD%97%E5%85%B8%E7%9A%84%E6%95%88%E7%8E%87%E9%AB%98%E8%BF%98%E6%98%AF%E7%94%A8lowcardinalitystring/:2:0","tags":["clickhousue"],"title":"ClickHouse 中用 int 类型作为字典的效率高，还是用LowCardinality(String)","uri":"/2020_12_31_clickhouse-%E4%B8%AD%E7%94%A8-int-%E7%B1%BB%E5%9E%8B%E4%BD%9C%E4%B8%BA%E5%AD%97%E5%85%B8%E7%9A%84%E6%95%88%E7%8E%87%E9%AB%98%E8%BF%98%E6%98%AF%E7%94%A8lowcardinalitystring/"},{"categories":["db"],"content":"建表语句 CREATE TABLE Dict ( id UInt32, int_dic UInt32, str_dic LowCardinality(String) ) ENGINE = MergeTree() ORDER BY (id) ","date":"2020-12-31","objectID":"/2020_12_31_clickhouse-%E4%B8%AD%E7%94%A8-int-%E7%B1%BB%E5%9E%8B%E4%BD%9C%E4%B8%BA%E5%AD%97%E5%85%B8%E7%9A%84%E6%95%88%E7%8E%87%E9%AB%98%E8%BF%98%E6%98%AF%E7%94%A8lowcardinalitystring/:2:1","tags":["clickhousue"],"title":"ClickHouse 中用 int 类型作为字典的效率高，还是用LowCardinality(String)","uri":"/2020_12_31_clickhouse-%E4%B8%AD%E7%94%A8-int-%E7%B1%BB%E5%9E%8B%E4%BD%9C%E4%B8%BA%E5%AD%97%E5%85%B8%E7%9A%84%E6%95%88%E7%8E%87%E9%AB%98%E8%BF%98%E6%98%AF%E7%94%A8lowcardinalitystring/"},{"categories":["db"],"content":"产生数据 INSERT INTO Dict SELECT number AS id, [1, 2, 3, 4, 5, 6,7,8,9,10][rand() % 10 + 1] AS int_dic, ['one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'ten'][rand() % 10 + 1] AS str_dic FROM numbers(10000000) ","date":"2020-12-31","objectID":"/2020_12_31_clickhouse-%E4%B8%AD%E7%94%A8-int-%E7%B1%BB%E5%9E%8B%E4%BD%9C%E4%B8%BA%E5%AD%97%E5%85%B8%E7%9A%84%E6%95%88%E7%8E%87%E9%AB%98%E8%BF%98%E6%98%AF%E7%94%A8lowcardinalitystring/:2:2","tags":["clickhousue"],"title":"ClickHouse 中用 int 类型作为字典的效率高，还是用LowCardinality(String)","uri":"/2020_12_31_clickhouse-%E4%B8%AD%E7%94%A8-int-%E7%B1%BB%E5%9E%8B%E4%BD%9C%E4%B8%BA%E5%AD%97%E5%85%B8%E7%9A%84%E6%95%88%E7%8E%87%E9%AB%98%E8%BF%98%E6%98%AF%E7%94%A8lowcardinalitystring/"},{"categories":["db"],"content":"测试结果 group 查询 int 类型 SELECT int_dic, count() FROM Dict GROUP BY int_dic ┌─int_dic─┬─count()─┐ │ 4 │ 999772 │ │ 3 │ 999515 │ │ 2 │ 999412 │ │ 5 │ 1000329 │ │ 1 │ 1000159 │ │ 6 │ 1000936 │ │ 7 │ 999680 │ │ 9 │ 1000776 │ │ 8 │ 999922 │ │ 10 │ 999499 │ └─────────┴─────────┘ 10 rows in set. Elapsed: 0.343 sec. Processed 10.00 million rows, 40.00 MB (29.19 million rows/s., 116.74 MB/s.) LowCardinality(String) 类型 SELECT str_dic, count() FROM Dict GROUP BY str_dic ┌─str_dic─┬─count()─┐ │ nine │ 1000776 │ │ six │ 1000936 │ │ two │ 999412 │ │ three │ 999515 │ │ one │ 1000159 │ │ four │ 999772 │ │ five │ 1000329 │ │ ten │ 999499 │ │ seven │ 999680 │ │ eight │ 999922 │ └─────────┴─────────┘ 10 rows in set. Elapsed: 0.159 sec. Processed 10.00 million rows, 10.02 MB (62.71 million rows/s., 62.84 MB/s.) in 查询 int 类型 SELECT count() FROM Dict WHERE int_dic IN (1, 2, 3) ┌─count()─┐ │ 2999086 │ └─────────┘ 1 rows in set. Elapsed: 0.094 sec. Processed 10.00 million rows, 40.00 MB (106.04 million rows/s., 424.17 MB/s.) LowCardinality(String) 类型 SELECT count() FROM Dict WHERE str_dic IN ('one', 'two', 'three') ┌─count()─┐ │ 2999086 │ └─────────┘ 1 rows in set. Elapsed: 0.041 sec. Processed 10.00 million rows, 10.02 MB (240.81 million rows/s., 241.32 MB/s.) 单个值查询 int 类型 SELECT count() FROM Dict WHERE int_dic = 1 ┌─count()─┐ │ 1000159 │ └─────────┘ 1 rows in set. Elapsed: 0.047 sec. Processed 10.00 million rows, 40.00 MB (213.06 million rows/s., 852.26 MB/s.) LowCardinality(String) 类型 SELECT count() FROM Dict WHERE str_dic = 'one' ┌─count()─┐ │ 1000159 │ └─────────┘ 1 rows in set. Elapsed: 0.032 sec. Processed 10.00 million rows, 10.02 MB (310.69 million rows/s., 311.35 MB/s.) ","date":"2020-12-31","objectID":"/2020_12_31_clickhouse-%E4%B8%AD%E7%94%A8-int-%E7%B1%BB%E5%9E%8B%E4%BD%9C%E4%B8%BA%E5%AD%97%E5%85%B8%E7%9A%84%E6%95%88%E7%8E%87%E9%AB%98%E8%BF%98%E6%98%AF%E7%94%A8lowcardinalitystring/:3:0","tags":["clickhousue"],"title":"ClickHouse 中用 int 类型作为字典的效率高，还是用LowCardinality(String)","uri":"/2020_12_31_clickhouse-%E4%B8%AD%E7%94%A8-int-%E7%B1%BB%E5%9E%8B%E4%BD%9C%E4%B8%BA%E5%AD%97%E5%85%B8%E7%9A%84%E6%95%88%E7%8E%87%E9%AB%98%E8%BF%98%E6%98%AF%E7%94%A8lowcardinalitystring/"},{"categories":["db"],"content":"结论 从测试结果来看，LowCardinality(String) 类型的性能大大超过我的预期。一开以为会比 int 类型稍微慢点 谁知却比 int 的性能好上一倍。通过这个测试顺利说服了同事😁 ","date":"2020-12-31","objectID":"/2020_12_31_clickhouse-%E4%B8%AD%E7%94%A8-int-%E7%B1%BB%E5%9E%8B%E4%BD%9C%E4%B8%BA%E5%AD%97%E5%85%B8%E7%9A%84%E6%95%88%E7%8E%87%E9%AB%98%E8%BF%98%E6%98%AF%E7%94%A8lowcardinalitystring/:4:0","tags":["clickhousue"],"title":"ClickHouse 中用 int 类型作为字典的效率高，还是用LowCardinality(String)","uri":"/2020_12_31_clickhouse-%E4%B8%AD%E7%94%A8-int-%E7%B1%BB%E5%9E%8B%E4%BD%9C%E4%B8%BA%E5%AD%97%E5%85%B8%E7%9A%84%E6%95%88%E7%8E%87%E9%AB%98%E8%BF%98%E6%98%AF%E7%94%A8lowcardinalitystring/"},{"categories":["db"],"content":"问题 今天在修改 ClickHouse 集群数据库表结构的时候 , 不知道由于什么原因 , 造成有两个节点 ( A 和 B , 其中 B 是副本节点 ) 的 zookeeper 的 metadata 数据不一致 每次在两个节点执行 alter table 的语句都会报 Metadata on replica is not up to date with common metadata in Zookeeper 错误 一开始的想法是把 A B 节点的 zookeeper 内的 columns 的值改成一样的就行了 . 没想到改了之后还是这个错 . 没办法 , 只能重建 zookeeper 上的 metadata 数据 (只重建出问题的表 , 其他的表不动) 注意 : 下面所有的操作没有特别的说明都是在 A 节点上进行的 ","date":"2020-11-01","objectID":"/2020.11.1_clickhouse-%E9%87%8D%E5%BB%BA-zookeeper-%E9%87%8C%E7%9A%84%E5%85%83%E6%95%B0%E6%8D%AE/:1:0","tags":["clickhouse"],"title":"ClickHouse 重建 zookeeper 里的元数据(ClickHouse 恢复数据)","uri":"/2020.11.1_clickhouse-%E9%87%8D%E5%BB%BA-zookeeper-%E9%87%8C%E7%9A%84%E5%85%83%E6%95%B0%E6%8D%AE/"},{"categories":["db"],"content":"备份数据 数据数据时有两个情况 : ClickHouse 在运行中 关于 freeze 具体的说明可以参考官方文档 ALTER TABLE $tab FREEZE 这个语句是在 ClickHouse 运行的情况下产生一份 $tab 这个表的数据备份 备份的数据的数据在 $ck主目录/shadow/$N/data/.... 中 路径中的 $N 是个变量 , 表示备份次数 , 如果是第一次运行那么值就是 1 例如 : alter table hera.user freeze; 运行上面的语句后 , 进入对应的目录运行 tree 命令看下结果 user 目录下就是备份的各个 partition 数据 ClickHouse 已经停止运行了 直接进入 data 目录把数据复制一份到其他目录 使用这种方式一定要确保 Clickhouse 已经停止运行 , 要不然备份的数据会有损坏的风险 ","date":"2020-11-01","objectID":"/2020.11.1_clickhouse-%E9%87%8D%E5%BB%BA-zookeeper-%E9%87%8C%E7%9A%84%E5%85%83%E6%95%B0%E6%8D%AE/:2:0","tags":["clickhouse"],"title":"ClickHouse 重建 zookeeper 里的元数据(ClickHouse 恢复数据)","uri":"/2020.11.1_clickhouse-%E9%87%8D%E5%BB%BA-zookeeper-%E9%87%8C%E7%9A%84%E5%85%83%E6%95%B0%E6%8D%AE/"},{"categories":["db"],"content":"恢复数据 建临时表 create table hera.temp (.....) 把上一步备份的数据转移到或复制到临时表的 detached 目录里 mv或cp /ck/shadow/1/data/hera/user/* /ck/data/hera/temp/detached chown clickhouse:clickhouse -R /ck/data/hera/temp/detached 上面的第二行是确保 detacehd目录下的所有文件的用户和组是 clickhouse 要不然有权限问题 恢复 A 节点数据 cd /ck/data/hera/temp/detached let i=1;for f in `ls -1` ; do echo $i $f;((i++)); echo \"alter table hera.temp attach part '$f';\"|clickhouse-client ; done 这一步是把备份的数据 attach 到 temp 表中 这一步完成后 A 节点的数据恢复就完成了 恢复 B 节点数据 在 B 节点上也建立一个临时表 , ClickHouse 自动会从 A 节点上拉取数据 ","date":"2020-11-01","objectID":"/2020.11.1_clickhouse-%E9%87%8D%E5%BB%BA-zookeeper-%E9%87%8C%E7%9A%84%E5%85%83%E6%95%B0%E6%8D%AE/:3:0","tags":["clickhouse"],"title":"ClickHouse 重建 zookeeper 里的元数据(ClickHouse 恢复数据)","uri":"/2020.11.1_clickhouse-%E9%87%8D%E5%BB%BA-zookeeper-%E9%87%8C%E7%9A%84%E5%85%83%E6%95%B0%E6%8D%AE/"},{"categories":["db"],"content":"扫尾工作 在 A B 节点上 drop 掉zookeeper 不一致的表 drop table user 在 A B 节点上把 temp 表的名字修改为原表的名字 rename table temp to user ","date":"2020-11-01","objectID":"/2020.11.1_clickhouse-%E9%87%8D%E5%BB%BA-zookeeper-%E9%87%8C%E7%9A%84%E5%85%83%E6%95%B0%E6%8D%AE/:4:0","tags":["clickhouse"],"title":"ClickHouse 重建 zookeeper 里的元数据(ClickHouse 恢复数据)","uri":"/2020.11.1_clickhouse-%E9%87%8D%E5%BB%BA-zookeeper-%E9%87%8C%E7%9A%84%E5%85%83%E6%95%B0%E6%8D%AE/"},{"categories":["db"],"content":"参考 https://github.com/ClickHouse/ClickHouse/issues/7972 https://clickhouse.tech/docs/en/sql-reference/statements/alter/partition/#alter_freeze-partition ","date":"2020-11-01","objectID":"/2020.11.1_clickhouse-%E9%87%8D%E5%BB%BA-zookeeper-%E9%87%8C%E7%9A%84%E5%85%83%E6%95%B0%E6%8D%AE/:5:0","tags":["clickhouse"],"title":"ClickHouse 重建 zookeeper 里的元数据(ClickHouse 恢复数据)","uri":"/2020.11.1_clickhouse-%E9%87%8D%E5%BB%BA-zookeeper-%E9%87%8C%E7%9A%84%E5%85%83%E6%95%B0%E6%8D%AE/"},{"categories":["code"],"content":"这段时间需要做一个签名验证的模块 . 因为 golang 的 rsa 性能问题需要用 nginx-opensty 来开发 , 在这个过程中遇到了一些问题和结果方法 , 在这里记录一下 . ","date":"2020-09-12","objectID":"/2020.9.12_openresty-%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/:0:0","tags":["nginx"],"title":"openresty 开发记录","uri":"/2020.9.12_openresty-%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/"},{"categories":["code"],"content":"安装 在 mac 下可以直接在 termina 中 brew install openresty/brew/openresty 来安装 安装后 operesty 的目录在 /usr/local/Cellar/openresty/1.17.8.2_1 下 , 最后是 openrsty 的版本号 nginx 配置文件的目录在 /usr/local/etc/openresty/ 下 nginx 的日志文件在 /usr/local/var/log/nginx/ 下 这些信息都可以使用openresty -h 来查看 安装好后可以直接用openresty 来启动 重载配置文件或停止 nginx 可以用 openresty -s signal 来实现 , 和 nginx -s signal 的效果是一样的 ","date":"2020-09-12","objectID":"/2020.9.12_openresty-%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/:1:0","tags":["nginx"],"title":"openresty 开发记录","uri":"/2020.9.12_openresty-%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/"},{"categories":["code"],"content":"hello world nginx 的默认文件是 /usr/local/etc/openresty/nginx.conf 修改该配置文件中的 http 块添加我们自己工作目录中的配置文件 include /Users/noelz/work/openresty/conf/*; 然后在 ~/work/openresty/conf/ 下添加 a.conf 文件 server { listen 6622; set $path /Users/noelz/work/openresty/code; location / { default_type text/html; lua_code_cache off; access_by_lua_file $path/hellow_world.lua; } } 在 ~/work/openresty/code/ 添加 hellow_world.lua 文件 ngx.say('hello world') 现在的 work 目录下的结构如下 ├── code │ └── hellow_world.lua └── conf └── a.conf 重载配置文件 openresty -s reload 然后在浏览器中打开 localhost:6622 ","date":"2020-09-12","objectID":"/2020.9.12_openresty-%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/:2:0","tags":["nginx"],"title":"openresty 开发记录","uri":"/2020.9.12_openresty-%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/"},{"categories":["code"],"content":"openresty 的项目组织 稍微复杂的一点的功能都不可能是单文件 , 肯定要引用其他的模块 . 既然要引用其他模块 , 肯定要让 openresty 知道你的代码目录在哪 . lua_package_path 这个配置项就能完成这项功能 比如下面这个配置文件 lua_package_cpath '/luatrace/code/?.so;/data/code/?.so;;'; lua_package_path '/luatrace/code/?.lua;/data/code/?.lua;;'; init_by_lua_file /luatrace/code/service/conf.lua; server { set $path /data/code/service; listen 80; location /get { default_type text/html; lua_code_cache off; access_by_lua_file $path/get.lua; } } 这个配置的前两行制定了 lua 和 c 代码或资源库的加载路径 比如在 get.lua 文件中引入了其他的模块 , 可以这样来引入 local signlib = require \"service.sign\" get.lua 和 sign.lua 的文件位置如下 ","date":"2020-09-12","objectID":"/2020.9.12_openresty-%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/:3:0","tags":["nginx"],"title":"openresty 开发记录","uri":"/2020.9.12_openresty-%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/"},{"categories":["code"],"content":"openresty 的加密库 lua_resty_nettle 因为我做的是签名验证相关的项目 , 肯定需要一些 sha256 或 hmac 之类的库 . 而**lua-resty-nettle** 就是干这个的 如果用 openresty 的包管理器 opm 来安装一般不会遇到什么问题 , 但是一开始我是直接把 nettle 库的 lua 代码直接下载下来放到 openresty 的 lib 目录下 . 因为 nettle 库会引用 c 语言编译好的 .so 文件 , 所以还需要安装 c 语言版的 nettle . 直接使用 brew install nettle 来安装就行了 ","date":"2020-09-12","objectID":"/2020.9.12_openresty-%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/:4:0","tags":["nginx"],"title":"openresty 开发记录","uri":"/2020.9.12_openresty-%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/"},{"categories":["code"],"content":"openresty 中不同的阶段 在 openrest 中可以指定不同的加载阶段来执行不同的 lua 代码 lua_package_cpath '/data/code/?.so;/data/code/?.so;;'; lua_package_path '/data/code/?.lua;/data/code/?.lua;;'; init_by_lua_file /data/code/service/conf.lua; server { set $path /data/code/service; listen 80; location /a { access_by_lua_file $path/get.lua; } location /b { rewrite_by_lua_file $path/inflate_body.lua; access_by_lua_file $path/post.lua; } } 第三行的 init_by_lua_file 是用来加载全局的配置文件的 , 在 openresty 刚启动的时候运行 第十一行的 rewrite_by_lua_file 通常是用来检查改写 URI 但也可以操作响应体 , 做编码解码工作 . 在这个示例中就是来解压 gzip 的 第八行和第十二行的 access_by_lua_file 就是来做主要的业务逻辑的 , 返回具体的相应内容 还有其他几个阶段 , 我这里没有用到 . 可以在这个链接找到更多的信息 ","date":"2020-09-12","objectID":"/2020.9.12_openresty-%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/:5:0","tags":["nginx"],"title":"openresty 开发记录","uri":"/2020.9.12_openresty-%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/"},{"categories":["code"],"content":"openresty 中的全局变量 在 openresty 启动的时候读取配置文件 , 把配置文件的配置项放到全局变量里 , 方便其他的模块来使用 . 这种需求可以使用模块变量来解决 . 定义在模块里面的变量称为模块变量。无论定义变量时有没有加 local ，有没有通过 _M 把变量引用起来， 定义在模块里面的变量都是模块变量 . 比如在上面的配置文件的第三行中的 lua 代码就是读取了配置文件然后返回一个模块变量 local lfs = require(\"lfs\") local str = require \"lib.str\" local conf = {} local path = '/data/conf/' for file in lfs.dir(path) do if string.match(file, '.json') then local key = str.split(file, '.')[1] file = io.open(path .. '/' .. file, \"r\") local content = file:read('*all') file:close() conf[key] = content end end return conf 然后在其他的模块中就可以引用上面的 conf 模块了 -- 引入 conf 模块 , 它就是个全局变量 local conf = require \"service.conf\" print(conf['xxx']) ","date":"2020-09-12","objectID":"/2020.9.12_openresty-%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/:6:0","tags":["nginx"],"title":"openresty 开发记录","uri":"/2020.9.12_openresty-%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/"},{"categories":["code"],"content":"lua 的 split 和 hex 虽然 lua 中有 string.gmatch 这样万能的字符串操作库 , 但是我只是临时用下 lua , gmatch 这个函数我有点用不来 . 所以下面是我封装的字符串分割 , 以及字符串转 16 进制的两个函数 function split(inputstr, sep) inputstr = inputstr or '' if sep == nil then sep = \"%s\" end local t = {} for str in string.gmatch(inputstr, \"([^\" .. sep .. \"]+)\") do table.insert(t, str) end return t end function hex(str, spacer) return string.lower((string.gsub(str, \"(.)\", function(c) return string.format(\"%02X%s\", string.byte(c), spacer or \"\") end))) end ","date":"2020-09-12","objectID":"/2020.9.12_openresty-%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/:7:0","tags":["nginx"],"title":"openresty 开发记录","uri":"/2020.9.12_openresty-%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/"},{"categories":["db"],"content":"clickhouse如何把两数组转为两列","date":"2020-09-04","objectID":"/2020.9.4_clickhouse%E5%A6%82%E4%BD%95%E6%8A%8A%E4%B8%A4%E6%95%B0%E7%BB%84%E8%BD%AC%E4%B8%BA%E4%B8%A4%E5%88%97/","tags":["clickhouse"],"title":"clickhouse如何把两数组转为两列","uri":"/2020.9.4_clickhouse%E5%A6%82%E4%BD%95%E6%8A%8A%E4%B8%A4%E6%95%B0%E7%BB%84%E8%BD%AC%E4%B8%BA%E4%B8%A4%E5%88%97/"},{"categories":["db"],"content":"在 clickhouse 中经常遇到把数组转为列的情况 . ","date":"2020-09-04","objectID":"/2020.9.4_clickhouse%E5%A6%82%E4%BD%95%E6%8A%8A%E4%B8%A4%E6%95%B0%E7%BB%84%E8%BD%AC%E4%B8%BA%E4%B8%A4%E5%88%97/:0:0","tags":["clickhouse"],"title":"clickhouse如何把两数组转为两列","uri":"/2020.9.4_clickhouse%E5%A6%82%E4%BD%95%E6%8A%8A%E4%B8%A4%E6%95%B0%E7%BB%84%E8%BD%AC%E4%B8%BA%E4%B8%A4%E5%88%97/"},{"categories":["db"],"content":"一个数组转为列 一个数组转列的情况很简单 , 直接使用 arrayjoin 函数来实现 select arrayJoin([1,2,3,4]) n ","date":"2020-09-04","objectID":"/2020.9.4_clickhouse%E5%A6%82%E4%BD%95%E6%8A%8A%E4%B8%A4%E6%95%B0%E7%BB%84%E8%BD%AC%E4%B8%BA%E4%B8%A4%E5%88%97/:1:0","tags":["clickhouse"],"title":"clickhouse如何把两数组转为两列","uri":"/2020.9.4_clickhouse%E5%A6%82%E4%BD%95%E6%8A%8A%E4%B8%A4%E6%95%B0%E7%BB%84%E8%BD%AC%E4%B8%BA%E4%B8%A4%E5%88%97/"},{"categories":["db"],"content":"两个数组转为两列遇到的问题 现有两个数组 , 想要把这两个数组转为两列 . 比如 变为 按照上面的经验分别对这两个数组使用 arrayjoin , 但是结果明显不符合我预期 with [1,2,3,4] as number, ['a','b','c','d'] as str select arrayJoin(number) n, arrayJoin(str) s; clickhouse 明显是把两列做了笛卡尔积 ","date":"2020-09-04","objectID":"/2020.9.4_clickhouse%E5%A6%82%E4%BD%95%E6%8A%8A%E4%B8%A4%E6%95%B0%E7%BB%84%E8%BD%AC%E4%B8%BA%E4%B8%A4%E5%88%97/:2:0","tags":["clickhouse"],"title":"clickhouse如何把两数组转为两列","uri":"/2020.9.4_clickhouse%E5%A6%82%E4%BD%95%E6%8A%8A%E4%B8%A4%E6%95%B0%E7%BB%84%E8%BD%AC%E4%B8%BA%E4%B8%A4%E5%88%97/"},{"categories":["db"],"content":"解决问题 这时可以用 clickhouse 的高级函数 arraymap 和 tuple 配合来实现这个变换 arraymap 的效果和 java8 里的 map 是一样的 . 即对数组的每一个元素做处理然后返回一个新的数组 上图就是对 [1,2,3] 数组进行加一 , 然后返回 [2,3,4] tuple 里可以装不同类型的数据 , 下图就是把一个 int 和一个 string 放在了一个 tuple 里 关于 tuple 更多的操作可以查阅官方文档 arrymap 不光可以对一个数组进行操作 , 还可以把不同的数组放到一个 tuple 数组中 . 官方文档的示例如下 : 这种方法就能实现我们的目标 \\ tuple.1 就是引用 tuple 内第一个元素 , 这里也看出 clickhouse 的索引下标是从 1 开始的 ","date":"2020-09-04","objectID":"/2020.9.4_clickhouse%E5%A6%82%E4%BD%95%E6%8A%8A%E4%B8%A4%E6%95%B0%E7%BB%84%E8%BD%AC%E4%B8%BA%E4%B8%A4%E5%88%97/:3:0","tags":["clickhouse"],"title":"clickhouse如何把两数组转为两列","uri":"/2020.9.4_clickhouse%E5%A6%82%E4%BD%95%E6%8A%8A%E4%B8%A4%E6%95%B0%E7%BB%84%E8%BD%AC%E4%B8%BA%E4%B8%A4%E5%88%97/"},{"categories":["db"],"content":"结果 最后结果就是通过 arraymap 和 tuple 配合来实现 sql 如下 with [1,2,3,4] as number, ['a','b','c','d'] as str select arrayJoin(arrayMap((x, y)-\u003e (x, y), number, str)) tuple, tuple.1 n, tuple.2 s; ","date":"2020-09-04","objectID":"/2020.9.4_clickhouse%E5%A6%82%E4%BD%95%E6%8A%8A%E4%B8%A4%E6%95%B0%E7%BB%84%E8%BD%AC%E4%B8%BA%E4%B8%A4%E5%88%97/:4:0","tags":["clickhouse"],"title":"clickhouse如何把两数组转为两列","uri":"/2020.9.4_clickhouse%E5%A6%82%E4%BD%95%E6%8A%8A%E4%B8%A4%E6%95%B0%E7%BB%84%E8%BD%AC%E4%B8%BA%E4%B8%A4%E5%88%97/"},{"categories":["db"],"content":"2021-01-15 日更新 最近发现 IPv4StringToNum 是用来比较版本号是更简单，性能更好的方式。 select IPv4StringToNum('2.7.14.23') \u003c IPv4StringToNum('2.12.8.12') comparse; 上面的结果是 1 符合我们的预期 但是这个函数有个缺点，版本号必须符合 ipv4 的格式，否者 IPv4StringToNum 会直接返回0 但巧合的是目前我们业务的版本号就是 1.2.3.4 这种格式，正巧符合 ipv4。 版本号预处理 对于不符合 ipv4 的版本号可以稍微处理下，比如只有两位（1.2）或三位的版本号（1.2.3）要补全成 ipv4 的形式 with '1.2' as shortVersion select concat(shortVersion, repeat('.0', toUInt64(4 - length(splitByString('.', shortVersion))))); 原理 clickhouse 是如何把 ipv4 的字符串变为 number 的？经过查询找到了 clickhouse 的计算流程 比如一个形如64.233.187.99的 ipv4 地址，会经过如下的计算 64*2^24 + 233*2^16 + 187*2^8 + 99 = 1089059683 这和 clickhouse 的结果完全一致 ","date":"2020-08-25","objectID":"/2020.8.25_clickhouse-%E5%A6%82%E4%BD%95%E6%AF%94%E8%BE%83%E7%89%88%E6%9C%AC%E5%8F%B7%E5%AD%97%E7%AC%A6%E4%B8%B2/:1:0","tags":["clickhouse"],"title":"clickhouse 比较版本号","uri":"/2020.8.25_clickhouse-%E5%A6%82%E4%BD%95%E6%AF%94%E8%BE%83%E7%89%88%E6%9C%AC%E5%8F%B7%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":["db"],"content":"以下为原文章 如果想要比较两个版本号的字符串, 比如 select '5.6.8.10'\u003e'5.6.8.2' 结果肯定是0即后者比较大, 但是在版本号的语义中明明是前者比较大. 在 mysql 中已经有了解决方案, 但是在 clickhouse 中我还没有在网络上搜索到. 但是可以借用 mysql 的思路来解决 ","date":"2020-08-25","objectID":"/2020.8.25_clickhouse-%E5%A6%82%E4%BD%95%E6%AF%94%E8%BE%83%E7%89%88%E6%9C%AC%E5%8F%B7%E5%AD%97%E7%AC%A6%E4%B8%B2/:2:0","tags":["clickhouse"],"title":"clickhouse 比较版本号","uri":"/2020.8.25_clickhouse-%E5%A6%82%E4%BD%95%E6%AF%94%E8%BE%83%E7%89%88%E6%9C%AC%E5%8F%B7%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":["db"],"content":"思路 把版本号按.分割, 返回一个字符串数组. 使用 splitByString 函数来分割 然后对数组每一个元素填充字符 '0' 使每一个元素都是 10 位, 比如上一步得到的字符串数组是 ['5','6','8','10']. 那么填充结果是 ['0000000005','0000000006','0000000008','0000000010'] . 这一步可以使用 arrayMap 函数来操作数组内每一个元素. arrayMap 的详细使用方法可以参考官方文档 然后把上一步得到的新数组拼接为一个完整的字符串, 可以使用 arrayStringConcat 函数来完成. 这一步的结果为0000000005000000000600000000080000000010 然后可以拿上一步拼接的字符串直接比较了 ","date":"2020-08-25","objectID":"/2020.8.25_clickhouse-%E5%A6%82%E4%BD%95%E6%AF%94%E8%BE%83%E7%89%88%E6%9C%AC%E5%8F%B7%E5%AD%97%E7%AC%A6%E4%B8%B2/:3:0","tags":["clickhouse"],"title":"clickhouse 比较版本号","uri":"/2020.8.25_clickhouse-%E5%A6%82%E4%BD%95%E6%AF%94%E8%BE%83%E7%89%88%E6%9C%AC%E5%8F%B7%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":["db"],"content":"完整的 sql with arrayStringConcat(arrayMap(x -\u003e concat(repeat('0', toUInt16(10 - length(x))), x), splitByString('.', '5.6.8.10')), '') as ver1, arrayStringConcat(arrayMap(x -\u003e concat(repeat('0', toUInt16(10 - length(x))), x), splitByString('.', '5.6.8.2')), '') as ver2 select ver1 \u003e ver2; ","date":"2020-08-25","objectID":"/2020.8.25_clickhouse-%E5%A6%82%E4%BD%95%E6%AF%94%E8%BE%83%E7%89%88%E6%9C%AC%E5%8F%B7%E5%AD%97%E7%AC%A6%E4%B8%B2/:4:0","tags":["clickhouse"],"title":"clickhouse 比较版本号","uri":"/2020.8.25_clickhouse-%E5%A6%82%E4%BD%95%E6%AF%94%E8%BE%83%E7%89%88%E6%9C%AC%E5%8F%B7%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":["db"],"content":"参考 https://tiramisu-navy.github.io/2018/09/27/mysql-compare-version(varchar)/ https://clickhouse.tech/docs/en/sql-reference/functions/higher-order-functions/#higher_order_functions-array-map https://stackoverflow.com/questions/34876711/mysql-query-compare-version-numbers ","date":"2020-08-25","objectID":"/2020.8.25_clickhouse-%E5%A6%82%E4%BD%95%E6%AF%94%E8%BE%83%E7%89%88%E6%9C%AC%E5%8F%B7%E5%AD%97%E7%AC%A6%E4%B8%B2/:5:0","tags":["clickhouse"],"title":"clickhouse 比较版本号","uri":"/2020.8.25_clickhouse-%E5%A6%82%E4%BD%95%E6%AF%94%E8%BE%83%E7%89%88%E6%9C%AC%E5%8F%B7%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":[],"content":"问题 linux的top命令的默认显示方式不是很直观。比如内存的显示方式是以字节为单位；每次刷新的间隔太慢；多个cpu核心没有全部显示等。每次进入top的界面都要设置一阵子才能舒适的使用。但是每次都要设置就很麻烦，所以这篇文章就是来展示我的top命令的一些设置以及如果保存这些设置。 ","date":"2020-07-10","objectID":"/2020.7.10_linux%E7%9A%84top%E5%91%BD%E4%BB%A4%E5%A6%82%E4%BD%95%E4%BF%9D%E5%AD%98%E8%AE%BE%E7%BD%AE/:1:0","tags":["linux"],"title":"linux的top命令如何保存设置","uri":"/2020.7.10_linux%E7%9A%84top%E5%91%BD%E4%BB%A4%E5%A6%82%E4%BD%95%E4%BF%9D%E5%AD%98%E8%AE%BE%E7%BD%AE/"},{"categories":[],"content":"如何保存设置 使用大写的W来保存自定义的设置，按下W后top界面上会显示设置保存的路径，如下图所示 ","date":"2020-07-10","objectID":"/2020.7.10_linux%E7%9A%84top%E5%91%BD%E4%BB%A4%E5%A6%82%E4%BD%95%E4%BF%9D%E5%AD%98%E8%AE%BE%E7%BD%AE/:2:0","tags":["linux"],"title":"linux的top命令如何保存设置","uri":"/2020.7.10_linux%E7%9A%84top%E5%91%BD%E4%BB%A4%E5%A6%82%E4%BD%95%E4%BF%9D%E5%AD%98%E8%AE%BE%E7%BD%AE/"},{"categories":[],"content":"个人设置 下面是我的一些个性化设置 内存为MB为单位显示 按多次e切换各个进程的内存单位 按多次E切换概览信息的内存单位，调整前后的效果如下所示 调整前： 调整后： 刷新频率 top的默认频率好像是3s，有时做压力测试的时候需要更高频的变化。输入d来修改频率，填入数字后，回车键确定。单位为秒，支持小数。我的频率是0.3秒 下图就是从3秒改为0.3秒 显示全部的cpu 按数字1来显示多个核心的cpu 效果如图 修改内存占用的进度条 按多次m来修改 修改前 修改后 我比较喜欢这种显示方式，感觉比较直观，能够直观看出内存的大体占用情况 ","date":"2020-07-10","objectID":"/2020.7.10_linux%E7%9A%84top%E5%91%BD%E4%BB%A4%E5%A6%82%E4%BD%95%E4%BF%9D%E5%AD%98%E8%AE%BE%E7%BD%AE/:3:0","tags":["linux"],"title":"linux的top命令如何保存设置","uri":"/2020.7.10_linux%E7%9A%84top%E5%91%BD%E4%BB%A4%E5%A6%82%E4%BD%95%E4%BF%9D%E5%AD%98%E8%AE%BE%E7%BD%AE/"},{"categories":[],"content":"参考 https://haydenjames.io/linux-top-customize-it/ ","date":"2020-07-10","objectID":"/2020.7.10_linux%E7%9A%84top%E5%91%BD%E4%BB%A4%E5%A6%82%E4%BD%95%E4%BF%9D%E5%AD%98%E8%AE%BE%E7%BD%AE/:4:0","tags":["linux"],"title":"linux的top命令如何保存设置","uri":"/2020.7.10_linux%E7%9A%84top%E5%91%BD%E4%BB%A4%E5%A6%82%E4%BD%95%E4%BF%9D%E5%AD%98%E8%AE%BE%E7%BD%AE/"},{"categories":[],"content":"最近需要测试gzip相关的内容。其中有一项需要对经过gzip压缩的request body进行处理。平时测试接口都是使用postman，这次我也希望用postman来完成 ","date":"2020-06-30","objectID":"/2020.6.30_postman%E5%8F%91%E9%80%81gzip%E7%9A%84%E8%AF%B7%E6%B1%82/:0:0","tags":[],"title":"使用Postman发送经过gzip压缩的request body","uri":"/2020.6.30_postman%E5%8F%91%E9%80%81gzip%E7%9A%84%E8%AF%B7%E6%B1%82/"},{"categories":[],"content":"实现 首先请求的header中必须有Content-Encoding=gzip，如图所示 想要使用postman发送gzip压缩的请求，只能通过发送文件的方式。所以要先把要发送的内容生成gzip文件 func TestGzip(t *testing.T) { var b bytes.Buffer w := gzip.NewWriter(\u0026b) _, _ = w.Write([]byte(\"gzip content.......\")) _ = w.Close() fmt.Println(ioutil.WriteFile(\"./gzip.txt\", b.Bytes(), os.FileMode(0777))) } 上面的go程序就是把gzip content.....这个string压缩为gzip文件 然后在body选项中选择binary类型，选择上一步生成的文件。点击发送 ","date":"2020-06-30","objectID":"/2020.6.30_postman%E5%8F%91%E9%80%81gzip%E7%9A%84%E8%AF%B7%E6%B1%82/:1:0","tags":[],"title":"使用Postman发送经过gzip压缩的request body","uri":"/2020.6.30_postman%E5%8F%91%E9%80%81gzip%E7%9A%84%E8%AF%B7%E6%B1%82/"},{"categories":["code","db"],"content":"问题 这两天需要把ClickHouse的查询结果进行统计然后存储起来，但是每一次查询的出来的数据量非常大。行数很多，某一天的count统计如下： 每次查询的数据有上亿行😢。在ClickHouse查询出结果后返回给client(就是我写的程序)，但是由于这个任务是在k8s内运行，限制只有400m的内存。所以很快就因为内存溢出而崩溃。 ","date":"2020-05-26","objectID":"/2020.5.26_golang%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%94%E5%9B%9E%E5%A4%A7%E9%87%8F%E6%95%B0%E6%8D%AE/:1:0","tags":["golang","clickhouse"],"title":"golang处理数据库返回大量数据","uri":"/2020.5.26_golang%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%94%E5%9B%9E%E5%A4%A7%E9%87%8F%E6%95%B0%E6%8D%AE/"},{"categories":["code","db"],"content":"之前的代码 一般的情况下都是把查询结果都放到slice内再返回比如这样： for scanner.Next() { value := reflect.New(base) if values, err := mapStructFieldsIntoSlice(value, columns, strict); err != nil { return err } else { if err := scanner.Scan(values...); err != nil { return err } else { appendFn(value) } } } 上面代码循环调用next方法，然后把读取的一行行数据放到slice中，这样很快就内存溢出了。 但是ClickHosue的drive内并不是一下就把所有的数据取回，而是维护一个stream。 当调用rows.next()时Clickhouse实现的Rows对象会从stream中读取一个block： 让我们看看stream的定义： stream就是一个容量为50的channel，也就是说当我们不执行next时，stream最多有50行的查询结果，这样就避免的了返回大量的查询结果而造成的崩溃。 ","date":"2020-05-26","objectID":"/2020.5.26_golang%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%94%E5%9B%9E%E5%A4%A7%E9%87%8F%E6%95%B0%E6%8D%AE/:2:0","tags":["golang","clickhouse"],"title":"golang处理数据库返回大量数据","uri":"/2020.5.26_golang%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%94%E5%9B%9E%E5%A4%A7%E9%87%8F%E6%95%B0%E6%8D%AE/"},{"categories":["code","db"],"content":"解决 通过上面的分析，我们也可以使用chan来解决 func BatchScanRows(db *sql.DB, ch chan interface{}, dest interface{}, query string, args ...interface{}) error { ..... 省略部分代码 ....... go func() { defer close(ch) for rows.Next() { v := reflect.New(itemType) err := rows.Scan(span(v.Interface(), columnIdx)...) if err != nil { logx.Error(err) break } ch \u003c- v.Interface() } }() return nil } 使用chan来接收rows.next的返回，这个chan我设置的大小是50000。然后再启动一个goroutine异步执行，保证立即返回。 func queryCH(heraCH *sql.DB, startStr string, endStr string) (map[int]statInfo, error) { chSQL := `select * from xxx` weeklyInfos := []*weeklyInfo{} ch := make(chan interface{}, 50000) err := ckgroup.BatchScanRows(heraCH, ch, \u0026weeklyInfos, chSQL, startStr, endStr) if err != nil { if err == sqlx.ErrNotFound { return nil, nil } return nil, err } statMap := map[int]statInfo{} //循环读取chan，直到chan close for data := range ch { v := data.(*weeklyInfo) weeklyId, err := getWeeklyId(v.Path) if err != nil { logx.Error(err) continue } statInfoItem := statMap[weeklyId] statInfoItem.ViewCount++ statInfoItem.ViewTotal += int64(v.StayTime) statMap[weeklyId] = statInfoItem } return statMap, nil } 这样就能边处理边从Clickhouse的服务器中取数据 ","date":"2020-05-26","objectID":"/2020.5.26_golang%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%94%E5%9B%9E%E5%A4%A7%E9%87%8F%E6%95%B0%E6%8D%AE/:3:0","tags":["golang","clickhouse"],"title":"golang处理数据库返回大量数据","uri":"/2020.5.26_golang%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%94%E5%9B%9E%E5%A4%A7%E9%87%8F%E6%95%B0%E6%8D%AE/"},{"categories":["tool"],"content":"clash配置说明","date":"2020-02-18","objectID":"/2020.2.18_mac%E4%B8%8Bclash%E6%95%99%E7%A8%8B/","tags":["clash"],"title":"Mac下clash教程","uri":"/2020.2.18_mac%E4%B8%8Bclash%E6%95%99%E7%A8%8B/"},{"categories":["tool"],"content":"问题 在Mac下想要舒服的使用UnblockNeteaseMusic肯定要和clashx配合使用，我在使用clashx时遇到了一些问题，现在记录下来方便大家参考 ","date":"2020-02-18","objectID":"/2020.2.18_mac%E4%B8%8Bclash%E6%95%99%E7%A8%8B/:1:0","tags":["clash"],"title":"Mac下clash教程","uri":"/2020.2.18_mac%E4%B8%8Bclash%E6%95%99%E7%A8%8B/"},{"categories":["tool"],"content":"简单使用 下载地址 clashx的配置文件夹路径在~/.config/clash/下，或者直接在状态栏通过gui操作 配置文件都是以yaml类型的。在配置文件夹下可以存在多个配置文件，方便在界面上切换不同的配置，如上图的三个配置文件test，config，ali 只有在设置为系统代理的情况下才能使代理有效 ","date":"2020-02-18","objectID":"/2020.2.18_mac%E4%B8%8Bclash%E6%95%99%E7%A8%8B/:2:0","tags":["clash"],"title":"Mac下clash教程","uri":"/2020.2.18_mac%E4%B8%8Bclash%E6%95%99%E7%A8%8B/"},{"categories":["tool"],"content":"我使用到的配置 详细的配置文档可以参考这个链接，下面说的都是我经常用到的 ","date":"2020-02-18","objectID":"/2020.2.18_mac%E4%B8%8Bclash%E6%95%99%E7%A8%8B/:3:0","tags":["clash"],"title":"Mac下clash教程","uri":"/2020.2.18_mac%E4%B8%8Bclash%E6%95%99%E7%A8%8B/"},{"categories":["tool"],"content":"Proxy字段 proxy字段接受对象数组，该字段用来制定代理服务器的描述，比如代理服务器的类型，ip地址，端口等 Proxy:- name:\"Unblock\"type:ssserver:music.desperadoj.comport:30001cipher:aes-128-gcmpassword:desperadoj.com- name:\"http_proxy\"type:httpserver:111.168.1.1port:1111 上面就声明了两个代理，在后面的字段中使用 ","date":"2020-02-18","objectID":"/2020.2.18_mac%E4%B8%8Bclash%E6%95%99%E7%A8%8B/:3:1","tags":["clash"],"title":"Mac下clash教程","uri":"/2020.2.18_mac%E4%B8%8Bclash%E6%95%99%E7%A8%8B/"},{"categories":["tool"],"content":"Proxy Group字段 该字段在有多个代理源的情况下，根据策略不同选择不用的代理源 策略有以下几种： url-test 可以自动选择与指定 URL 测速后，延迟最短的服务器 allback 可以尽量按照用户书写的服务器顺序，在确保服务器可用的情况下，自动选择服务器 load-balance 可以使相同 eTLD 请求在同一条代理线路上 select 用来允许用户手动选择 代理服务器 或 服务器组 下面的事例是select类型的策略 Proxy Group:- name:\"🎵 Netease Music\"type:selectproxies:- 🎶 Unblock- DIRECT 上面的配置里我指定了两个代理源，在gui里的反馈就是这样的： 这种策略方便我们手动的切换 ","date":"2020-02-18","objectID":"/2020.2.18_mac%E4%B8%8Bclash%E6%95%99%E7%A8%8B/:3:2","tags":["clash"],"title":"Mac下clash教程","uri":"/2020.2.18_mac%E4%B8%8Bclash%E6%95%99%E7%A8%8B/"},{"categories":["tool"],"content":"Rule字段 该字段也是数组，数组的item是字符串 该字符串由逗号分隔,具体的规则是：匹配规则,匹配源,使用哪个代理 Rule:# domain类型是全匹配，只有访问的url是apps.apple.com时，才是使用名为“🎵 Netease Music”的代理- DOMAIN,apps.apple.com,🎵 Netease Music#DOMAIN-SUFFIX是后缀域名匹配,例如这个规则可以匹配blog.126.com这个url，之后使用\"direct\"这个代理- DOMAIN-SUFFIX,126.com,DIRECT#domain-keyword是关键词匹配- DOMAIN-KEYWORD,baidu,DIRECT#ip匹配- IP-CIDR,127.0.0.0/8,DIRECT ","date":"2020-02-18","objectID":"/2020.2.18_mac%E4%B8%8Bclash%E6%95%99%E7%A8%8B/:3:3","tags":["clash"],"title":"Mac下clash教程","uri":"/2020.2.18_mac%E4%B8%8Bclash%E6%95%99%E7%A8%8B/"},{"categories":["tool"],"content":"参考 https://github.com/Hackl0us/SS-Rule-Snippet/blob/master/LAZY_RULES/clash.yaml https://github.com/nondanee/UnblockNeteaseMusic https://github.com/yichengchen/clashX ","date":"2020-02-18","objectID":"/2020.2.18_mac%E4%B8%8Bclash%E6%95%99%E7%A8%8B/:4:0","tags":["clash"],"title":"Mac下clash教程","uri":"/2020.2.18_mac%E4%B8%8Bclash%E6%95%99%E7%A8%8B/"},{"categories":["code"],"content":"问题 今天我在写代码的时候遇到了标题所说的问题，我用google搜索了下也没有找到想要的答案。后来通过几个测试用例试了下这个发现问题有点意思 ","date":"2019-12-04","objectID":"/2019.12.04_%E5%BD%93golang%E5%A4%9A%E4%B8%AA%E5%AD%97%E6%AE%B5%E7%9A%84json-tag%E7%9B%B8%E5%90%8C%E6%97%B6%E4%BC%9A%E6%80%8E%E4%B9%88%E6%A0%B7/:1:0","tags":["golang"],"title":"当golang多个字段的json tag相同时会怎么样?","uri":"/2019.12.04_%E5%BD%93golang%E5%A4%9A%E4%B8%AA%E5%AD%97%E6%AE%B5%E7%9A%84json-tag%E7%9B%B8%E5%90%8C%E6%97%B6%E4%BC%9A%E6%80%8E%E4%B9%88%E6%A0%B7/"},{"categories":["code"],"content":"情况1 都是普通字段 type sameTag struct { A string `json:\"a\"` B string `json:\"a\"` Other string `json:\"other\"` } func TestSameJson(t *testing.T) { tag := sameTag{\"a\", \"b\", \"other filed\"} bytes, e := json.Marshal(tag) fmt.Println(string(bytes)) fmt.Println(e) } 输出结果: {\"other\":\"other filed\"} \u003cnil\u003e 上面代码的A、B字段的tag相同。该struct在序列化后只保留了other字段，AB字段因为冲突直接消失了 ","date":"2019-12-04","objectID":"/2019.12.04_%E5%BD%93golang%E5%A4%9A%E4%B8%AA%E5%AD%97%E6%AE%B5%E7%9A%84json-tag%E7%9B%B8%E5%90%8C%E6%97%B6%E4%BC%9A%E6%80%8E%E4%B9%88%E6%A0%B7/:2:0","tags":["golang"],"title":"当golang多个字段的json tag相同时会怎么样?","uri":"/2019.12.04_%E5%BD%93golang%E5%A4%9A%E4%B8%AA%E5%AD%97%E6%AE%B5%E7%9A%84json-tag%E7%9B%B8%E5%90%8C%E6%97%B6%E4%BC%9A%E6%80%8E%E4%B9%88%E6%A0%B7/"},{"categories":["code"],"content":"情况2 普通字段和匿名字段 type innerStruct struct { A string `json:\"a\"` } type sameTag struct { innerStruct B string `json:\"a\"` Other string `json:\"other\"` } func TestSameJson(t *testing.T) { tag := sameTag{innerStruct{\"inner\"}, \"outter\", \"other filed\"} bytes, e := json.Marshal(tag) fmt.Println(string(bytes)) fmt.Println(e) } 输出结果： {\"a\":\"outter\",\"other\":\"other filed\"} \u003cnil\u003e 这次的AB的tag都相同，但是序列化结果采用了B字段。因为B字段的优先级比较高，一般字段的优先级比匿名字段高 ","date":"2019-12-04","objectID":"/2019.12.04_%E5%BD%93golang%E5%A4%9A%E4%B8%AA%E5%AD%97%E6%AE%B5%E7%9A%84json-tag%E7%9B%B8%E5%90%8C%E6%97%B6%E4%BC%9A%E6%80%8E%E4%B9%88%E6%A0%B7/:3:0","tags":["golang"],"title":"当golang多个字段的json tag相同时会怎么样?","uri":"/2019.12.04_%E5%BD%93golang%E5%A4%9A%E4%B8%AA%E5%AD%97%E6%AE%B5%E7%9A%84json-tag%E7%9B%B8%E5%90%8C%E6%97%B6%E4%BC%9A%E6%80%8E%E4%B9%88%E6%A0%B7/"},{"categories":["code"],"content":"情况3 都是匿名字段 type innerA struct { A string `json:\"a\"` } type innerB struct { B string `json:\"a\"` } type sameTag struct { innerA innerB Other string `json:\"other\"` } func TestSameJson(t *testing.T) { tag := sameTag{innerA{\"innerA\"}, innerB{\"innerB\"}, \"other filed\"} bytes, e := json.Marshal(tag) fmt.Println(string(bytes)) fmt.Println(e) } 输出结果: {\"other\":\"other filed\"} \u003cnil\u003e 这次输出和情况1一样，还是优先级的问题。innerA和innerB都是匿名字段所以AB字段的优先级一样，这样就冲突了，序列化忽略这两个字段。 ","date":"2019-12-04","objectID":"/2019.12.04_%E5%BD%93golang%E5%A4%9A%E4%B8%AA%E5%AD%97%E6%AE%B5%E7%9A%84json-tag%E7%9B%B8%E5%90%8C%E6%97%B6%E4%BC%9A%E6%80%8E%E4%B9%88%E6%A0%B7/:4:0","tags":["golang"],"title":"当golang多个字段的json tag相同时会怎么样?","uri":"/2019.12.04_%E5%BD%93golang%E5%A4%9A%E4%B8%AA%E5%AD%97%E6%AE%B5%E7%9A%84json-tag%E7%9B%B8%E5%90%8C%E6%97%B6%E4%BC%9A%E6%80%8E%E4%B9%88%E6%A0%B7/"},{"categories":["code"],"content":"总结 总的来说就是因为字段优先级的原因，会采用优先级高的字段。当优先级相同时跳过这些相同的字段。 这段逻辑时json的源码中也有体现 encode.go文件中的dominantField方法就是来判断存不存在优先级相同的字段 dominantField looks through the fields, all of which are known to have the same name, to find the single field that dominates the others using Go's embedding rules, modified by the presence of JSON tags. If there are multiple top-level fields, the boolean will be false: This condition is an error in Go and we skip all the fields. ","date":"2019-12-04","objectID":"/2019.12.04_%E5%BD%93golang%E5%A4%9A%E4%B8%AA%E5%AD%97%E6%AE%B5%E7%9A%84json-tag%E7%9B%B8%E5%90%8C%E6%97%B6%E4%BC%9A%E6%80%8E%E4%B9%88%E6%A0%B7/:5:0","tags":["golang"],"title":"当golang多个字段的json tag相同时会怎么样?","uri":"/2019.12.04_%E5%BD%93golang%E5%A4%9A%E4%B8%AA%E5%AD%97%E6%AE%B5%E7%9A%84json-tag%E7%9B%B8%E5%90%8C%E6%97%B6%E4%BC%9A%E6%80%8E%E4%B9%88%E6%A0%B7/"},{"categories":["编程"],"content":"golang的MarshalJSON没有调用、无效","date":"2019-11-08","objectID":"/2019.11.08_marshaljson%E6%B2%A1%E6%9C%89%E8%B0%83%E7%94%A8%E6%97%A0%E6%95%88/","tags":["golang"],"title":"MarshalJSON没有调用、无效？","uri":"/2019.11.08_marshaljson%E6%B2%A1%E6%9C%89%E8%B0%83%E7%94%A8%E6%97%A0%E6%95%88/"},{"categories":["编程"],"content":"问题 今天我在golang自定义json的序列化时，发现我的struct实现MarshalJSON()竟然没有效果，还是按照默认的方式来序列化。这让我非常郁闷☹，后来我查找了一些资料发现这个问题不简单。。 下面是我有问题的代码 type str string func (s *str) MarshalJSON() (data []byte, err error) { return json.Marshal(\"bbb\") } func TestStr(t *testing.T) { var s str = \"aaa\" bytes, _ := json.Marshal(s) fmt.Println(string(bytes)) //我想让他序列化为\"bbb\"但是输出结果还是\"aaa\" } ","date":"2019-11-08","objectID":"/2019.11.08_marshaljson%E6%B2%A1%E6%9C%89%E8%B0%83%E7%94%A8%E6%97%A0%E6%95%88/:1:0","tags":["golang"],"title":"MarshalJSON没有调用、无效？","uri":"/2019.11.08_marshaljson%E6%B2%A1%E6%9C%89%E8%B0%83%E7%94%A8%E6%97%A0%E6%95%88/"},{"categories":["编程"],"content":"pointer receiver 和value receiver type T struct{} func (t *T) pointerMethod() { } // pointer receiver func (t T) valueMethod() { } // value receiver 上面两个方法分别就是pointer receiver和value receiver 由于golang没有面向对象那一套东西，上面的两行代码可以视为下面的形式 func pointerMethod(t *T) { } func valueMethod(t T) { } 所以在golang中value变量只能调用value receiver的方法，pointer只能调用pointer receiver的方法。比如： var t1 T t1.valueMethod()//正确 t1.pointerMethod()//错误? var t2 *T t2.valueMethod()//错误？ t2.pointerMethod()//正确 其实我们实际可以相互调用的 var t1 T t1.valueMethod()//正确 t1.pointerMethod()//正确 var t2 *T t2.valueMethod()//正确 t2.pointerMethod()//正确 因为golang的底层帮我们做了一层隐式转换 t1.pointerMethod() == (\u0026t1).pointerMethod() t2.valueMethod()==(*t2).valueMethod() 总的来说 T可以调用value receiver和pointer receiver方法 *T如果是可以取地址(addressable)的变量，也是可以调用value receiver和pointer receiver方法 如果*T是不可去地址的变量，那只能调用pointer receiver方法 关于什么是可以去地址的变量，什么是不可以取地址。可以参考这篇文章链接 ","date":"2019-11-08","objectID":"/2019.11.08_marshaljson%E6%B2%A1%E6%9C%89%E8%B0%83%E7%94%A8%E6%97%A0%E6%95%88/:2:0","tags":["golang"],"title":"MarshalJSON没有调用、无效？","uri":"/2019.11.08_marshaljson%E6%B2%A1%E6%9C%89%E8%B0%83%E7%94%A8%E6%97%A0%E6%95%88/"},{"categories":["编程"],"content":"Interface的value receiver 和pointer receiver 在讨论interface的receiver之前，先看下interface在使用中的一些问题。 type S struct { } func (s *S) pointerMethod() { } func (s S) valueMethod() { } type I interface { pointerMethod() valueMethod() } func TestInterface(t *testing.T) { value := S{} pointer := \u0026S{} var i I i = pointer //可以赋值 i=value //编译错误 // cannot use value (type S) as type I in assignment: //S does not implement I (pointerMethod method has pointer receiver) } 上面的代码为什么pointer可以赋值给i，而value却不行？ 因为pointer变量可以通过*pointer来调用value receiver也就是valueMethod 但是value变量就不行。 因为存储在interface里的值是不能取地址的，所以调用不了pointerMethod 总的来说当一个接口I有value receiver和pointer receiver时，指针变量（*T）是满足这个接口的 但是值类型的变量(T)就不行，因为T赋值给I后，不能取地址 ","date":"2019-11-08","objectID":"/2019.11.08_marshaljson%E6%B2%A1%E6%9C%89%E8%B0%83%E7%94%A8%E6%97%A0%E6%95%88/:3:0","tags":["golang"],"title":"MarshalJSON没有调用、无效？","uri":"/2019.11.08_marshaljson%E6%B2%A1%E6%9C%89%E8%B0%83%E7%94%A8%E6%97%A0%E6%95%88/"},{"categories":["编程"],"content":"解决问题 经过上面的解释，我们现在自然的找到了解决我一开始遇到的问题的方法 这里有两种解决方法 把s的类型改为指针 type str string func (s *str) MarshalJSON() (data []byte, err error) { return json.Marshal(\"bbb\") } func TestStr(t *testing.T) { temp := \"aaa\" var s *str = (*str)(\u0026temp) //改为指针 bytes, _ := json.Marshal(s) fmt.Println(string(bytes)) } 从pointer receiver改为value receiver type str string func (s str) MarshalJSON() (data []byte, err error) { //把 * 去掉 return json.Marshal(\"bbb\") } func TestStr(t *testing.T) { var s str = \"aaa\" bytes, _ := json.Marshal(s) fmt.Println(string(bytes)) } ","date":"2019-11-08","objectID":"/2019.11.08_marshaljson%E6%B2%A1%E6%9C%89%E8%B0%83%E7%94%A8%E6%97%A0%E6%95%88/:4:0","tags":["golang"],"title":"MarshalJSON没有调用、无效？","uri":"/2019.11.08_marshaljson%E6%B2%A1%E6%9C%89%E8%B0%83%E7%94%A8%E6%97%A0%E6%95%88/"},{"categories":["编程"],"content":"参考 https://stackoverflow.com/questions/33587227/golang-method-sets-pointer-vs-value-receiver https://stackoverflow.com/questions/21390979/custom-marshaljson-never-gets-called-in-go http://shanks.leanote.com/post/Untitled-55ca439338f41148cd000759-17 https://sanyuesha.com/2017/07/22/how-to-understand-go-interface/ https://colobu.com/2018/02/27/go-addressable/ https://tonybai.com/2015/09/17/7-things-you-may-not-pay-attation-to-in-go/ ","date":"2019-11-08","objectID":"/2019.11.08_marshaljson%E6%B2%A1%E6%9C%89%E8%B0%83%E7%94%A8%E6%97%A0%E6%95%88/:5:0","tags":["golang"],"title":"MarshalJSON没有调用、无效？","uri":"/2019.11.08_marshaljson%E6%B2%A1%E6%9C%89%E8%B0%83%E7%94%A8%E6%97%A0%E6%95%88/"},{"categories":["生活"],"content":"上海护照办理流程分享","date":"2019-11-03","objectID":"/2019.11.03_%E4%B8%8A%E6%B5%B7%E5%8A%9E%E7%90%86%E6%8A%A4%E7%85%A7%E6%B5%81%E7%A8%8B/","tags":["生活"],"title":"上海办理护照流程","uri":"/2019.11.03_%E4%B8%8A%E6%B5%B7%E5%8A%9E%E7%90%86%E6%8A%A4%E7%85%A7%E6%B5%81%E7%A8%8B/"},{"categories":["生活"],"content":"前言 我办理护照并不是因为目前有出过国的需求。而是国外的一些平台的身份认证需要上传护照，中国居民身份证在国外平台的认可度是没有护照高的。所以现在闲着没事办个护照，以备不时之需。 ","date":"2019-11-03","objectID":"/2019.11.03_%E4%B8%8A%E6%B5%B7%E5%8A%9E%E7%90%86%E6%8A%A4%E7%85%A7%E6%B5%81%E7%A8%8B/:1:0","tags":["生活"],"title":"上海办理护照流程","uri":"/2019.11.03_%E4%B8%8A%E6%B5%B7%E5%8A%9E%E7%90%86%E6%8A%A4%E7%85%A7%E6%B5%81%E7%A8%8B/"},{"categories":["生活"],"content":"必要条件和证件 在上海办理护照要满足以下三个条件其中之一 上海户籍 上海居住证 在上海连续缴纳一年社保 我就是以第三个条件来办理的护照 证件只需要身份证 ","date":"2019-11-03","objectID":"/2019.11.03_%E4%B8%8A%E6%B5%B7%E5%8A%9E%E7%90%86%E6%8A%A4%E7%85%A7%E6%B5%81%E7%A8%8B/:2:0","tags":["生活"],"title":"上海办理护照流程","uri":"/2019.11.03_%E4%B8%8A%E6%B5%B7%E5%8A%9E%E7%90%86%E6%8A%A4%E7%85%A7%E6%B5%81%E7%A8%8B/"},{"categories":["生活"],"content":"办理流程 ","date":"2019-11-03","objectID":"/2019.11.03_%E4%B8%8A%E6%B5%B7%E5%8A%9E%E7%90%86%E6%8A%A4%E7%85%A7%E6%B5%81%E7%A8%8B/:3:0","tags":["生活"],"title":"上海办理护照流程","uri":"/2019.11.03_%E4%B8%8A%E6%B5%B7%E5%8A%9E%E7%90%86%E6%8A%A4%E7%85%A7%E6%B5%81%E7%A8%8B/"},{"categories":["生活"],"content":"预约 预约有两种方式一种是提前网上预约(点击进入预约网址)。第二种是到现场扫码预约 我是提前在网上预约的 预约的地址是自贸区的日京路38号，时间段上午9：00-10：00 ","date":"2019-11-03","objectID":"/2019.11.03_%E4%B8%8A%E6%B5%B7%E5%8A%9E%E7%90%86%E6%8A%A4%E7%85%A7%E6%B5%81%E7%A8%8B/:3:1","tags":["生活"],"title":"上海办理护照流程","uri":"/2019.11.03_%E4%B8%8A%E6%B5%B7%E5%8A%9E%E7%90%86%E6%8A%A4%E7%85%A7%E6%B5%81%E7%A8%8B/"},{"categories":["生活"],"content":"办理前 日京路的办理点是在二楼，由台阶上去，进入大门进去就是办理大厅 办公时间 办理大厅内 ","date":"2019-11-03","objectID":"/2019.11.03_%E4%B8%8A%E6%B5%B7%E5%8A%9E%E7%90%86%E6%8A%A4%E7%85%A7%E6%B5%81%E7%A8%8B/:3:2","tags":["生活"],"title":"上海办理护照流程","uri":"/2019.11.03_%E4%B8%8A%E6%B5%B7%E5%8A%9E%E7%90%86%E6%8A%A4%E7%85%A7%E6%B5%81%E7%A8%8B/"},{"categories":["生活"],"content":"拍照 如果提前预约了，可以直接去拍照，如果没预约过要到前台扫码预约。 如果只是办理护照，拍照是免费的。如果还要办理签证，需要另付30元打印照片，支持支付宝微信 ","date":"2019-11-03","objectID":"/2019.11.03_%E4%B8%8A%E6%B5%B7%E5%8A%9E%E7%90%86%E6%8A%A4%E7%85%A7%E6%B5%81%E7%A8%8B/:3:3","tags":["生活"],"title":"上海办理护照流程","uri":"/2019.11.03_%E4%B8%8A%E6%B5%B7%E5%8A%9E%E7%90%86%E6%8A%A4%E7%85%A7%E6%B5%81%E7%A8%8B/"},{"categories":["生活"],"content":"打印申请表 拍完照片后，去旁边的机器打印申请表，这里需要身份证。 拿到申请表后找前台取号排队。这里可以选择邮寄证件，邮费是到付。 ","date":"2019-11-03","objectID":"/2019.11.03_%E4%B8%8A%E6%B5%B7%E5%8A%9E%E7%90%86%E6%8A%A4%E7%85%A7%E6%B5%81%E7%A8%8B/:3:4","tags":["生活"],"title":"上海办理护照流程","uri":"/2019.11.03_%E4%B8%8A%E6%B5%B7%E5%8A%9E%E7%90%86%E6%8A%A4%E7%85%A7%E6%B5%81%E7%A8%8B/"},{"categories":["生活"],"content":"办理付款 拿到号后，就可以坐着休息了。叫到你时去对应的窗口办理就行了。 办理过程就是核对信息，录入指纹签字这几项，速度很快。 最后就是付费了，办证的费用120元，支持现金、支付包微信、银行卡、信用卡。 最后把申请表，快递单号交给前台，流程结束。 ","date":"2019-11-03","objectID":"/2019.11.03_%E4%B8%8A%E6%B5%B7%E5%8A%9E%E7%90%86%E6%8A%A4%E7%85%A7%E6%B5%81%E7%A8%8B/:3:5","tags":["生活"],"title":"上海办理护照流程","uri":"/2019.11.03_%E4%B8%8A%E6%B5%B7%E5%8A%9E%E7%90%86%E6%8A%A4%E7%85%A7%E6%B5%81%E7%A8%8B/"},{"categories":["生活"],"content":"总结 从我进入办理大厅，到办理完成走出大厅，全程花费了我22分钟🙂和120元和少许的邮费 整个流程非常的快捷方便👍 ","date":"2019-11-03","objectID":"/2019.11.03_%E4%B8%8A%E6%B5%B7%E5%8A%9E%E7%90%86%E6%8A%A4%E7%85%A7%E6%B5%81%E7%A8%8B/:4:0","tags":["生活"],"title":"上海办理护照流程","uri":"/2019.11.03_%E4%B8%8A%E6%B5%B7%E5%8A%9E%E7%90%86%E6%8A%A4%E7%85%A7%E6%B5%81%E7%A8%8B/"},{"categories":null,"content":"Github Actions是github搞的一个持续集成服务,现在还在测试中,如果想要使用需要到官网去申请. 现在我想使用github actions实现vue-element-admin做的一个管理后台的自动构建发布到生产服务器的一系列过程 ","date":"2019-10-21","objectID":"/2019.10.21_%E5%BD%93github-action%E9%81%87%E5%88%B0element-ui-admin/:0:0","tags":["vue","git","前端"],"title":"当github action遇到element-ui-admin","uri":"/2019.10.21_%E5%BD%93github-action%E9%81%87%E5%88%B0element-ui-admin/"},{"categories":null,"content":"新建github workflow 进入github仓库的主页点击actions就可以创建一个新的workflow 新建文件的路径在仓库根目录的./github/workflows/ 我之前误操作不知道为什么新建在仓库的根目录 ","date":"2019-10-21","objectID":"/2019.10.21_%E5%BD%93github-action%E9%81%87%E5%88%B0element-ui-admin/:1:0","tags":["vue","git","前端"],"title":"当github action遇到element-ui-admin","uri":"/2019.10.21_%E5%BD%93github-action%E9%81%87%E5%88%B0element-ui-admin/"},{"categories":null,"content":"字段说明 name 字段是 workflow 的名称。如果省略该字段，默认为当前 workflow 的文件名 name:CI on 字段指定触发 workflow 的条件 //push时触发on:[push]//push和pull时触发on:[push, pull_request]//只在master分支push时触发on:push:branches:- master jobs 表示要执行的一项或多项任务 jobs:my_job1:xxxxxxxxxxxmy_job2:xxxxxxxx my_job1和my_job2称为job_id jobs.\u003cjob_id\u003e.runs-on 字段指定运行所需要的虚拟机环境。它是必填字段。目前可用的虚拟机如下 ubuntu-latest，ubuntu-18.04或ubuntu-16.04 windows-latest，windows-2019或windows-2016 macOS-latest或macOS-10.14 jobs.\u003cjob_id\u003e.steps 字段指定每个 Job 的运行步骤，可以包含一个或多个步骤。每个步骤都可以指定以下字段 steps.name：步骤名称 steps.run：该步骤运行的linux命令 如pwd ls-l 等 steps.uses :该步骤使用actions market中的别人写好的action steps.uses.with:该步骤是填入别人定义好的参数,比如在hellow_action中定义好了三个参数( first_name, middle_name, and last_name ) jobs:my_first_job:steps:- name:My first stepuses:actions/hello_world@masterwith:first_name:Monamiddle_name:Thelast_name:Octocat steps.uses.env和with类似 ","date":"2019-10-21","objectID":"/2019.10.21_%E5%BD%93github-action%E9%81%87%E5%88%B0element-ui-admin/:2:0","tags":["vue","git","前端"],"title":"当github action遇到element-ui-admin","uri":"/2019.10.21_%E5%BD%93github-action%E9%81%87%E5%88%B0element-ui-admin/"},{"categories":null,"content":"我的action ","date":"2019-10-21","objectID":"/2019.10.21_%E5%BD%93github-action%E9%81%87%E5%88%B0element-ui-admin/:3:0","tags":["vue","git","前端"],"title":"当github action遇到element-ui-admin","uri":"/2019.10.21_%E5%BD%93github-action%E9%81%87%E5%88%B0element-ui-admin/"},{"categories":null,"content":"下载项目代码 uses:actions/checkout@master @master是指定master的代码 如果想要下载某个tag或某个commit的代码,如下 actions/checkout@74bc508# 指向一个 commitactions/checkout@v1.0 # 指向一个标签actions/checkout@master # 指向一个分支 ","date":"2019-10-21","objectID":"/2019.10.21_%E5%BD%93github-action%E9%81%87%E5%88%B0element-ui-admin/:3:1","tags":["vue","git","前端"],"title":"当github action遇到element-ui-admin","uri":"/2019.10.21_%E5%BD%93github-action%E9%81%87%E5%88%B0element-ui-admin/"},{"categories":null,"content":"npm build - name:npm install, build, and testrun:|npm install npm run build:prod --if-presentenv:CI:true ","date":"2019-10-21","objectID":"/2019.10.21_%E5%BD%93github-action%E9%81%87%E5%88%B0element-ui-admin/:3:2","tags":["vue","git","前端"],"title":"当github action遇到element-ui-admin","uri":"/2019.10.21_%E5%BD%93github-action%E9%81%87%E5%88%B0element-ui-admin/"},{"categories":null,"content":"ssh到生产服务器备份现在正在运行的静态网页 这一部使用了appleboy的ssh-action,这个action就是从action market中找到的 具体文档在这 name:backup admin-webuses:appleboy/ssh-action@masterwith:host:${{ secrets.SERVER_IP }}username:rootpassword:${{ secrets.FTP_PASSWORD }}port:22script:|cp -r /root/glass/admin-web /root/glass/admin-web-old 如果actions的配置文件里重要的信息,比如密码或密钥可以使用秘密环境变量来替代${{secrets.xxxx}} ","date":"2019-10-21","objectID":"/2019.10.21_%E5%BD%93github-action%E9%81%87%E5%88%B0element-ui-admin/:3:3","tags":["vue","git","前端"],"title":"当github action遇到element-ui-admin","uri":"/2019.10.21_%E5%BD%93github-action%E9%81%87%E5%88%B0element-ui-admin/"},{"categories":null,"content":"把dist部署到生产服务器 vue-element-admin build之后的静态文件在根目录的dist文件夹,所以我要把dist文件夹内的文件都上穿到生产服务器里 这里使用了SamKirkland/FTP-Deploy-Action@2.0.0 文档 uses:SamKirkland/FTP-Deploy-Action@2.0.0env:FTP_SERVER:${{ secrets.SERVER_IP }}FTP_USERNAME:rootFTP_PASSWORD:${{ secrets.FTP_PASSWORD }}METHOD:sftpLOCAL_DIR:dist #要上传的目录REMOTE_DIR:/root/glass/admin-web #上传到服务器的目录ARGS:--delete ","date":"2019-10-21","objectID":"/2019.10.21_%E5%BD%93github-action%E9%81%87%E5%88%B0element-ui-admin/:3:4","tags":["vue","git","前端"],"title":"当github action遇到element-ui-admin","uri":"/2019.10.21_%E5%BD%93github-action%E9%81%87%E5%88%B0element-ui-admin/"},{"categories":null,"content":"全部action文件 name:Node CIon:push:branches:- masterjobs:build:runs-on:ubuntu-lateststeps:- uses:actions/checkout@master- name:Use Node.js 12.xuses:actions/setup-node@v1with:node-version:'12.x'- name:npm install, build, and testrun:|npm install npm run build:prod --if-presentenv:CI:true- name:backup admin-webuses:appleboy/ssh-action@masterwith:host:${{ secrets.SERVER_IP }}username:rootpassword:${{ secrets.FTP_PASSWORD }}port:22script:|cp -r /root/glass/admin-web /root/glass/admin-web-old- name:deploy to serveruses:SamKirkland/FTP-Deploy-Action@2.0.0env:FTP_SERVER:${{ secrets.SERVER_IP }}FTP_USERNAME:rootFTP_PASSWORD:${{ secrets.FTP_PASSWORD }}METHOD:sftpLOCAL_DIR:distREMOTE_DIR:/root/glass/admin-webARGS:--delete 运行结果 ","date":"2019-10-21","objectID":"/2019.10.21_%E5%BD%93github-action%E9%81%87%E5%88%B0element-ui-admin/:4:0","tags":["vue","git","前端"],"title":"当github action遇到element-ui-admin","uri":"/2019.10.21_%E5%BD%93github-action%E9%81%87%E5%88%B0element-ui-admin/"},{"categories":null,"content":"参考 https://help.github.com/en/github/automating-your-workflow-with-github-actions/virtual-environments-for-github-actions https://github.com/SamKirkland/FTP-Deploy-Action https://github.com/appleboy/ssh-action ","date":"2019-10-21","objectID":"/2019.10.21_%E5%BD%93github-action%E9%81%87%E5%88%B0element-ui-admin/:5:0","tags":["vue","git","前端"],"title":"当github action遇到element-ui-admin","uri":"/2019.10.21_%E5%BD%93github-action%E9%81%87%E5%88%B0element-ui-admin/"},{"categories":null,"content":"zip命令 使用unzip的时候有时候想把文件解压到一个新的文件夹，如果直接写一个新目录会报错 在要解压的目的地的前面加个参数－d，就能新建一个不存的目录 ","date":"2019-10-13","objectID":"/2019.10.13_linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:0:1","tags":["linux"],"title":"Linux常用命令","uri":"/2019.10.13_linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"mysql相关命令 自动补全 mysql的命令也是有自动补全的．需要的参数如下 mysql -u root -p --auto-rehash 开启后能自动补全了 但是这个只能补数据名和表名之类的，不能补全show databases 之类的命令，很蛋疼 连接远程mysql -h参数就是远程地址 mysql -h 192.168.1.221 -u root -p ","date":"2019-10-13","objectID":"/2019.10.13_linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:0:2","tags":["linux"],"title":"Linux常用命令","uri":"/2019.10.13_linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"问题 如果想要在go build生成的可执行文件中注入编译时间，git hash等信息。可以在编译的时候使用-ldflags -X参数来注入变量 -ldfflags -X 可以在go install 、go build、go run 、go test中使用 go build -ldflags “-X ' packageName.varName=cmd ' “ ","date":"2019-08-26","objectID":"/2019.9.12_golang-ldfalgs%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7/:1:0","tags":null,"title":"golang ldfalgs的小技巧","uri":"/2019.9.12_golang-ldfalgs%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7/"},{"categories":null,"content":"样例 package main import \"fmt\" var ( time = \"not set\" git = \"not set\" ) func main() { fmt.Println(\"build time:\", time) fmt.Println(\"git log:\", git) } 想要在build的时候改变time和git的值，可以这么做： powershell(cmd有问题): go build -ldflags \"-X 'main.buildTime=$(date)' -X 'main.gitHash=$(git log --pretty=format:\"%h\" -1)'\" main.go linux: go build -ldflags \"-X 'main.time=$(date -u --rfc-3339=seconds)' -X 'main.git=$(git log --pretty=format:\"%h\" -1)'\" main.go 运行结果: build date: 2019-09-12 06:57:45+00:00 git hash: e1ac7a6 ","date":"2019-08-26","objectID":"/2019.9.12_golang-ldfalgs%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7/:2:0","tags":null,"title":"golang ldfalgs的小技巧","uri":"/2019.9.12_golang-ldfalgs%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7/"},{"categories":null,"content":"注意 只能给string赋值,不能是bool,int 只能是变量，不能是常量 -X importpath.name=val, 其中importpath是变量所在包的的路径， name是包中定义的变量， val 是需要在编译时设置的变量的值(string) 如果val是命令的结果，命令中可能有空格之类的特殊符号，建议 importpath.nmae=val 用单引号括起来,如：`importpath.nmae=val` ","date":"2019-08-26","objectID":"/2019.9.12_golang-ldfalgs%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7/:3:0","tags":null,"title":"golang ldfalgs的小技巧","uri":"/2019.9.12_golang-ldfalgs%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7/"},{"categories":null,"content":"参考 https://stackoverflow.com/questions/47509272/how-to-set-package-variable-using-ldflags-x-in-golang-build https://2young.2simple.top/article/golang/golang%E5%9C%A8%E7%BC%96%E8%AF%91%E6%97%B6%E4%BD%BF%E7%94%A8ldflags%E5%8A%A8%E6%80%81%E8%AE%BE%E7%BD%AE%E5%8F%98%E9%87%8F%E7%9A%84%E5%80%BC.html ","date":"2019-08-26","objectID":"/2019.9.12_golang-ldfalgs%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7/:4:0","tags":null,"title":"golang ldfalgs的小技巧","uri":"/2019.9.12_golang-ldfalgs%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7/"},{"categories":null,"content":"问题 Golang的方法接收者就是在函数名前的括号内的东西 如 func (self Car) run() // (self car)就是方法接收者 在JetBrains系类的开发工具中（IntelliJ、Goland）如果方法接收者名字是self me this类似的词，IDE会提示Receiver has generic name信息 如下图所示 Go中的函数 在Go中，无论是方法还是函数都可以把他作为一个普通的函数来调用 Demo: type Car struct { i int } func (c Car) run() { fmt.Println(\"my receiver is:\", c.i) } func TestSelf(t *testing.T) { a := Car{1} a.run() Car.run(Car{22}) } 运行结果如下： my receiver is: 1 my receiver is: 22 Go的方法只是语法糖而已，本质还是第一个参数是接收者的普通函数 解释 在其他面向对象的语言中this self me这些字段都有具体的含义，比如可以访问自己的私有方法或字段或者有其他特殊的含义。 但是在go中最好不用使用这些词，因为方法接收者只是一个普通的参数而，起不到这些词字面上的含义 go官方的代码规范也提到了这一点 The name of a method’s receiver should be a reflection of its identity; often a one or two letter abbreviation of its type suffices (such as “c” or “cl” for “Client”). Don’t use generic names such as “me”, “this” or “self”, identifiers typical of object-oriented languages that gives the method a special meaning. In Go, the receiver of a method is just another parameter and therefore, should be named accordingly. The name need not be as descriptive as that of a method argument, as its role is obvious and serves no documentary purpose. It can be very short as it will appear on almost every line of every method of the type; familiarity admits brevity. Be consistent, too: if you call the receiver “c” in one method, don’t call it “cl” in another. 如果想关闭掉这个提示可以在Setting-\u003eEditor-\u003eInspections-\u003eGo-\u003eCode style issues 中把Receiver has generic name这一项取消 参考 https://stackoverflow.com/questions/23482068/in-go-is-naming-the-receiver-variable-self-misleading-or-good-practice https://stackoverflow.com/questions/38025743/go-why-shouldnt-use-this-for-method-receiver-name https://github.com/golang/go/wiki/CodeReviewComments#receiver-names ","date":"2019-08-26","objectID":"/2019.8.26_receiver-has-generic-name/:0:0","tags":null,"title":"Receiver has generic name","uri":"/2019.8.26_receiver-has-generic-name/"},{"categories":null,"content":"当想要在服务器上部署一个常驻程序时，不想让程序随着Terminal的退出而中止，你可以使用docker nohup supervisor 这些工具来实现。但是处于想学习Linux中Systemd的目的，我使用Systemd来实现把一个Golang程序作为一个系统服务 ","date":"2019-07-29","objectID":"/2019.7.29_systemd%E9%9B%86%E6%88%90golang%E7%A8%8B%E5%BA%8F/:0:0","tags":null,"title":"Systemd集成Golang程序","uri":"/2019.7.29_systemd%E9%9B%86%E6%88%90golang%E7%A8%8B%E5%BA%8F/"},{"categories":null,"content":"新建Systemd的Service 目前go build得到的可执行文件放在/root/glass/go下 首先新建Service，名称叫做glass-api touch /lib/systemd/system/glass-api.service 下一步，编辑该文件 [Unit] Description=Glass admin's api [Service] Type=simple Restart=always RestartSec=5s ExecStart=/root/glass/go/main WorkingDirectory=/root/glass/go/ [Install] WantedBy=multi-user.target ExecStart是go可执行文件的路径 WorkingDirectory要注意，如果程序中使用了相对路径来加载一些配置文件，如果在Service中没有配置WorkingDirectory，默认是根路径，所以配置文件就从根路径来寻找，会造成一些意向不到的情况 ","date":"2019-07-29","objectID":"/2019.7.29_systemd%E9%9B%86%E6%88%90golang%E7%A8%8B%E5%BA%8F/:0:1","tags":null,"title":"Systemd集成Golang程序","uri":"/2019.7.29_systemd%E9%9B%86%E6%88%90golang%E7%A8%8B%E5%BA%8F/"},{"categories":null,"content":"运行Service 启动 service glass-api start 停止 service glass-api stop 查看状态 service glass-api status 输出结果 Redirecting to /bin/systemctl status glass-api.service ● glass-api.service - Glass admin's api Loaded: loaded (/usr/lib/systemd/system/glass-api.service; disabled; vendor preset: disabled) Active: active (running) since Sat 2019-07-27 19:00:09 CST; 1 day 15h ago Main PID: 22559 (main) Memory: 7.3M CGroup: /system.slice/glass-api.service └─22559 /root/glass/go/main 如果想要开机启动 service glass-api enable ","date":"2019-07-29","objectID":"/2019.7.29_systemd%E9%9B%86%E6%88%90golang%E7%A8%8B%E5%BA%8F/:0:2","tags":null,"title":"Systemd集成Golang程序","uri":"/2019.7.29_systemd%E9%9B%86%E6%88%90golang%E7%A8%8B%E5%BA%8F/"},{"categories":null,"content":"参考 https://liqiang.io/post/run-golang-binary-with-systemd https://github.com/kardianos/service ","date":"2019-07-29","objectID":"/2019.7.29_systemd%E9%9B%86%E6%88%90golang%E7%A8%8B%E5%BA%8F/:0:3","tags":null,"title":"Systemd集成Golang程序","uri":"/2019.7.29_systemd%E9%9B%86%E6%88%90golang%E7%A8%8B%E5%BA%8F/"},{"categories":null,"content":"获取毫秒时间戳 //第一种 time.Now().UnixNano() / int64(time.Millisecond) //第二种 time.Now().UnixNano() / 1e6 ","date":"2019-07-25","objectID":"/time%E5%8C%85%E7%9B%B8%E5%85%B3%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/:0:1","tags":null,"title":"golang time包相关的一些问题","uri":"/time%E5%8C%85%E7%9B%B8%E5%85%B3%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/"},{"categories":null,"content":"time.Unix()用法 //函数定义 func Unix(sec int64, nsec int64) Time unix有两个参数 第一个参数秒级的时间戳 第二个参数是纳秒 当使用sec时，把nsec置为0，使用nsec时把sec置为0 //秒时间戳-\u003eTime time.Unix(1564063799, 0) //纳秒时间戳-\u003eTime time.Unix(0, 1564063799695197200) //毫秒时间戳-\u003eTime time.Unix(0, 1564063799695*int64(time.Millisecond)) ","date":"2019-07-25","objectID":"/time%E5%8C%85%E7%9B%B8%E5%85%B3%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/:0:2","tags":null,"title":"golang time包相关的一些问题","uri":"/time%E5%8C%85%E7%9B%B8%E5%85%B3%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/"},{"categories":null,"content":"Time.Format format默认使用的时本地时区，如果要指定时区方式如下 var cstZone = time.FixedZone(\"CST\", 8*3600) // 东八 time.Now().In(cstZone).Format(\"2006-01-02 15:04:05\") ","date":"2019-07-25","objectID":"/time%E5%8C%85%E7%9B%B8%E5%85%B3%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/:0:3","tags":null,"title":"golang time包相关的一些问题","uri":"/time%E5%8C%85%E7%9B%B8%E5%85%B3%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/"},{"categories":null,"content":"Time.Parse time.Parse() 只会在参数里有指明时区信息、时区信息以 zone offset 形式（如 2018-01-01 12:11:11 +0800 CST）表示、表示结果与本地时区等价时，才会使用本地时区，否则使用读出的时区。若参数里没有指明时区信息，则使用 UTC 时间。所以一般建议使用time.ParseInLocation() time.ParseInLocation(\"2006-01-02 15:04:05\", \"2018-01-01 12:11:11\",time.Local) ","date":"2019-07-25","objectID":"/time%E5%8C%85%E7%9B%B8%E5%85%B3%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/:0:4","tags":null,"title":"golang time包相关的一些问题","uri":"/time%E5%8C%85%E7%9B%B8%E5%85%B3%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/"},{"categories":null,"content":"MySql索引优化 ","date":"2019-03-25","objectID":"/2019.3.25_mysql%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96/:0:0","tags":null,"title":"MySql索引优化","uri":"/2019.3.25_mysql%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96/"},{"categories":null,"content":"语法 create table user_info ( id int AUTO_INCREMENT, name varchar(20), age int(3), email varchar(256), PRIMARY KEY (id) ); create index idx_user_nameAgeEmail on user_info (name,age,email); create table t ( a varchar(20), b int(3), c varchar(20) ); create index idx_a_b_c on t (a,b,c); create index \u003c索引名称\u003e on \u003c表名\u003e （\u003c列名\u003e,.....） ","date":"2019-03-25","objectID":"/2019.3.25_mysql%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96/:0:1","tags":null,"title":"MySql索引优化","uri":"/2019.3.25_mysql%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96/"},{"categories":null,"content":"不合适创建索引的情况 更新多，查询少 数据重复度高的字段： 比如一张表有两个字段“名”和“姓”，“名”就合适建立索引，“姓”不合适 ","date":"2019-03-25","objectID":"/2019.3.25_mysql%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96/:0:2","tags":null,"title":"MySql索引优化","uri":"/2019.3.25_mysql%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96/"},{"categories":null,"content":"索引优化 最左前缀 使用索引的时候要一定要注意在创建索引时的顺序 ","date":"2019-03-25","objectID":"/2019.3.25_mysql%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96/:0:3","tags":null,"title":"MySql索引优化","uri":"/2019.3.25_mysql%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96/"},{"categories":null,"content":"问题 之前想反编译jar包,在网上了找了一些反编译的工具感觉都不太好用.就来我发现idea自带的反编译插件挺好用,但是没有GUI只能使用命令. ","date":"2019-03-25","objectID":"/%E4%BD%BF%E7%94%A8idea%E8%87%AA%E5%B8%A6%E7%9A%84plugin%E5%8F%8D%E7%BC%96%E8%AF%91jar/:0:1","tags":null,"title":"使用idea自带的plugin反编译jar","uri":"/%E4%BD%BF%E7%94%A8idea%E8%87%AA%E5%B8%A6%E7%9A%84plugin%E5%8F%8D%E7%BC%96%E8%AF%91jar/"},{"categories":null,"content":"使用 这个插件在\u003cidea_home\u003e/plugins/java-decompiler/lib/java-decompiler.jar.这个jar不能直接用java -jar运行,这个jar没有只能main函数,直接java -jar会报错,下面是使用方法 java -cp java-decompiler.jar org.jetbrains.java.decompiler.main.decompiler.ConsoleDecompiler -dgs=true siddhi-core.jar mysrc ","date":"2019-03-25","objectID":"/%E4%BD%BF%E7%94%A8idea%E8%87%AA%E5%B8%A6%E7%9A%84plugin%E5%8F%8D%E7%BC%96%E8%AF%91jar/:0:2","tags":null,"title":"使用idea自带的plugin反编译jar","uri":"/%E4%BD%BF%E7%94%A8idea%E8%87%AA%E5%B8%A6%E7%9A%84plugin%E5%8F%8D%E7%BC%96%E8%AF%91jar/"},{"categories":null,"content":"参数说明 java-decompiler.jar是插件 org.jetbrains.java.decompiler.main.decompiler.ConsoleDecompiler是主函数入口 -dgs=true 是这个主函数的参数,具体的含义和其他参数具体参考 该插件github链接 siddhi-core.jar指需要反编译的jar mysrc指定反编译后的输出路径 命令执行完成之后输出的是.jar文件,解压之后就是源码了 ","date":"2019-03-25","objectID":"/%E4%BD%BF%E7%94%A8idea%E8%87%AA%E5%B8%A6%E7%9A%84plugin%E5%8F%8D%E7%BC%96%E8%AF%91jar/:0:3","tags":null,"title":"使用idea自带的plugin反编译jar","uri":"/%E4%BD%BF%E7%94%A8idea%E8%87%AA%E5%B8%A6%E7%9A%84plugin%E5%8F%8D%E7%BC%96%E8%AF%91jar/"},{"categories":null,"content":"“阶”的含义 B-树的所有结点中最多可以拥有的子结点的个数为“阶”，用M表示，下图是一个三阶B-树 三阶B树中所有节点的子节点最多有三个，不能超过三个 下图是一个四阶B树 ","date":"2019-03-21","objectID":"/2019.3.21_b-%E6%A0%91%E7%9A%84%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5/:0:1","tags":null,"title":"B-树的一些概念","uri":"/2019.3.21_b-%E6%A0%91%E7%9A%84%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5/"},{"categories":null,"content":"M阶B树中每个节点的个数 每个节点中最多有M-1个元素 每个节点最少有[M/2]-1个元素除了根节点，[]表示向上取整 比如一个五阶B树，每个节点内最少有[5/2]-1=2个元素，最多有5-1=4个元素 ","date":"2019-03-21","objectID":"/2019.3.21_b-%E6%A0%91%E7%9A%84%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5/:0:2","tags":null,"title":"B-树的一些概念","uri":"/2019.3.21_b-%E6%A0%91%E7%9A%84%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5/"},{"categories":null,"content":"当元素个数超过最大个数时 选取元素中第[M/2]个元素，进行分裂 一个四阶B树，最多有3个元素，当再插入一个元素时，已经4个元素了，要选取第[4/2]=2个元素进行分裂，分解的过程如下 ","date":"2019-03-21","objectID":"/2019.3.21_b-%E6%A0%91%E7%9A%84%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5/:0:3","tags":null,"title":"B-树的一些概念","uri":"/2019.3.21_b-%E6%A0%91%E7%9A%84%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5/"},{"categories":null,"content":"参考 B-树插入删除可视化：https://www.cs.usfca.edu/~galles/visualization/Algorithms.html ","date":"2019-03-21","objectID":"/2019.3.21_b-%E6%A0%91%E7%9A%84%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5/:0:4","tags":null,"title":"B-树的一些概念","uri":"/2019.3.21_b-%E6%A0%91%E7%9A%84%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5/"},{"categories":null,"content":"安装运行 ","date":"2019-03-18","objectID":"/2019.3.18_voltdb%E5%85%A5%E9%97%A8/:0:0","tags":null,"title":"VoltDB入门","uri":"/2019.3.18_voltdb%E5%85%A5%E9%97%A8/"},{"categories":null,"content":"环境要求 python2.7以上，不支持python3 java8 ","date":"2019-03-18","objectID":"/2019.3.18_voltdb%E5%85%A5%E9%97%A8/:0:1","tags":null,"title":"VoltDB入门","uri":"/2019.3.18_voltdb%E5%85%A5%E9%97%A8/"},{"categories":null,"content":"安装 到官网注册个账号才能把下载链接发到邮箱，很蛋疼，不能直接下载 解压 把voltdb/bin/加入环境变量 ","date":"2019-03-18","objectID":"/2019.3.18_voltdb%E5%85%A5%E9%97%A8/:0:2","tags":null,"title":"VoltDB入门","uri":"/2019.3.18_voltdb%E5%85%A5%E9%97%A8/"},{"categories":null,"content":"运行 初始化工作空间 voltdb inti 在当前目录生成voltdbroot文件夹，里面存放着数据库数据之类的东西，还有命令行快照，用来恢复数据 运行voltdb voltdb start 通过cmd操作数据库 sqlcmd 用过sqlcmd进入命令行,和MySQL的命令行差不多 关闭 voltadmin shutdown Java连接VoltDB 驱动jar \u003c!-- https://mvnrepository.com/artifact/org.voltdb/voltdbclient --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.voltdb\u003c/groupId\u003e \u003cartifactId\u003evoltdbclient\u003c/artifactId\u003e \u003cversion\u003e8.4.1\u003c/version\u003e \u003c/dependency\u003e 传统的jdbc方式连接VoltDB String driver = \"org.voltdb.jdbc.Driver\"; String url = \"jdbc:voltdb://host:port?jdbc.committhrowexception=false\u0026jdbc.rollbackthrowexception=false\u0026autoreconnect=true\"; Class.forName(driver); this.connection = DriverManager.getConnection(url); 因为voltdb不支持传统的事务方式，所以在jdbc添加两个参数使在使用事务时不报异常 使用client来连接VoltDB ClientConfig config = new ClientConfig(); this.client = ClientFactory.createClient(config); client.createConnection(\"192.168.1.241\"); 如果使用这种方式来操作数据库，所有的操作只能通过存储过程来实现 简单性能测试 启动时占用550M左右的内存 每秒45次插入时,CPU占用大概20% 每秒3900次插入时,CPU满载,没有数据丢失 对100W单表的一个字段进行like查询,耗时0.2S 三百万条下图类似的数据，加上voltdb本身的进程大概占用1.22G内存 其他 voltdb是内存关系数据库,所以查询比redis方便 不支持beganTransaction autoCommit之类的操作,要想进行事务相关的操作,只能使用存储过程 不支持外键,自增字段之类的 sqlcmd可以执行sql脚本 sqlcmd \u003c test.sql 参考 https://docs.voltdb.com/UsingVoltDB/ddlref_createtable.php https://docs.voltdb.com/ ","date":"2019-03-18","objectID":"/2019.3.18_voltdb%E5%85%A5%E9%97%A8/:0:3","tags":null,"title":"VoltDB入门","uri":"/2019.3.18_voltdb%E5%85%A5%E9%97%A8/"},{"categories":null,"content":"步骤 设置mysql免密码登陆 编辑/etc/mysql/my.cnf文件,在最后加入以下设置 [mysqld] skip-grant-tables=1 重启mysql $ sudo service mysql stop $ sudo service mysql strat 进入mysql，先修改验证方式，再改密码 $ mysql //修改验证方式 mysql\u003e USE mysql; mysql\u003e UPDATE user SET plugin='mysql_native_password' WHERE User='root'; //修改密码 mysql\u003e update mysql.user set authentication_string=password('123qwe') where user='root' and Host = 'localhost'; //刷新权限 mysql\u003e flush privileges; //推出 musql\u003e exit; 重启mysql服务 登陆mysql $ mysql -uroot -p 参考 https://stackoverflow.com/questions/39281594/error-1698-28000-access-denied-for-user-rootlocalhost# ","date":"2019-03-16","objectID":"/2019.3.16_ubuntu18.04-%E4%BF%AE%E6%94%B9mysql5.7%E9%BB%98%E8%AE%A4root%E5%AF%86%E7%A0%81/:0:0","tags":null,"title":"Ubuntu18.04 修改Mysql5.7默认root密码","uri":"/2019.3.16_ubuntu18.04-%E4%BF%AE%E6%94%B9mysql5.7%E9%BB%98%E8%AE%A4root%E5%AF%86%E7%A0%81/"},{"categories":null,"content":"安装 ","date":"2019-03-16","objectID":"/2019.3.16_wsl%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8lxrunoffline%E5%A4%87%E4%BB%BD/:0:0","tags":null,"title":"WSL安装和使用LxRunOffline备份","uri":"/2019.3.16_wsl%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8lxrunoffline%E5%A4%87%E4%BB%BD/"},{"categories":null,"content":"开启WSL组件 Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux ","date":"2019-03-16","objectID":"/2019.3.16_wsl%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8lxrunoffline%E5%A4%87%E4%BB%BD/:0:1","tags":null,"title":"WSL安装和使用LxRunOffline备份","uri":"/2019.3.16_wsl%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8lxrunoffline%E5%A4%87%E4%BB%BD/"},{"categories":null,"content":"下载镜像 由于我的Win10是精简版所以没用应用商店所以只能手动下载镜像 各个发行版 https://docs.microsoft.com/en-us/windows/wsl/install-manua ","date":"2019-03-16","objectID":"/2019.3.16_wsl%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8lxrunoffline%E5%A4%87%E4%BB%BD/:0:2","tags":null,"title":"WSL安装和使用LxRunOffline备份","uri":"/2019.3.16_wsl%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8lxrunoffline%E5%A4%87%E4%BB%BD/"},{"categories":null,"content":"安装 把Ubuntu.appx重命名为Ubuntu.zip 解压 对Ubuntu.exe右键以管理员运行，输入用户名和密码即安装完成 ","date":"2019-03-16","objectID":"/2019.3.16_wsl%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8lxrunoffline%E5%A4%87%E4%BB%BD/:0:3","tags":null,"title":"WSL安装和使用LxRunOffline备份","uri":"/2019.3.16_wsl%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8lxrunoffline%E5%A4%87%E4%BB%BD/"},{"categories":null,"content":"修改默认用户 在解压的根目录打开powershell ubuntu config --default-user \u003cusername\u003e 备份WSL ","date":"2019-03-16","objectID":"/2019.3.16_wsl%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8lxrunoffline%E5%A4%87%E4%BB%BD/:0:4","tags":null,"title":"WSL安装和使用LxRunOffline备份","uri":"/2019.3.16_wsl%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8lxrunoffline%E5%A4%87%E4%BB%BD/"},{"categories":null,"content":"安装LxRunOffline https://github.com/DDoSolitary/LxRunOffline 安装好后最好重启下电脑，如果不重启可能有问题 ","date":"2019-03-16","objectID":"/2019.3.16_wsl%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8lxrunoffline%E5%A4%87%E4%BB%BD/:0:5","tags":null,"title":"WSL安装和使用LxRunOffline备份","uri":"/2019.3.16_wsl%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8lxrunoffline%E5%A4%87%E4%BB%BD/"},{"categories":null,"content":"常用LxRunOffline命令 //已经安装的wsl LxRunOffline.exe list //安装wsl LxRunOffline.exe install //备份wsl LxRunOffline.exe export //启动一个wsl LxRunOffline.exe run ","date":"2019-03-16","objectID":"/2019.3.16_wsl%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8lxrunoffline%E5%A4%87%E4%BB%BD/:0:6","tags":null,"title":"WSL安装和使用LxRunOffline备份","uri":"/2019.3.16_wsl%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8lxrunoffline%E5%A4%87%E4%BB%BD/"},{"categories":null,"content":"备份wsl 先查看当前系统中存在的wsl \u003e LxRunOffline.exe list Ubuntu-18.04 开始备份 LxRunOffline.exe export -n Ubuntu-18.04 -f backup.tar.gz -n ：wsl的别名，就是之前用list查看的其中一个 -f ：备份的路径，我这直接备份到当前路径backup.tar.gz 还原wsl LxRunOffline.exe install -n new-linux -d .\\ -f D:\\temp\\backup.tar.gz -n ：起个名字 -d ：wsl安装目录 -f ：备份文件目录 启动备份的wsl LxRunOffline.exe run -n new-linux 参考 https://github.com/DDoSolitary/LxRunOffline https://docs.microsoft.com/en-us/windows/wsl/install-on-server https://askubuntu.com/questions/816732/how-to-change-default-user-in-wsl-ubuntu-bash-on-windows-10 ","date":"2019-03-16","objectID":"/2019.3.16_wsl%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8lxrunoffline%E5%A4%87%E4%BB%BD/:0:7","tags":null,"title":"WSL安装和使用LxRunOffline备份","uri":"/2019.3.16_wsl%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8lxrunoffline%E5%A4%87%E4%BB%BD/"},{"categories":null,"content":"四个事物等级 read uncommitted ：有可能脏读 一个事务过程中读取到了，另一个事务的中途数据 read committed ：有可能不可重复读 即在一次事务之间，进行了两次读取，但是结果不一样，可能第一次id为1的人叫“李三”，第二次读id为1的人就叫了“李四”。因为读取操作不会阻止其他事务 repetable read ：有可能幻读 幻读侧重的方面是某一次的 select 操作得到的结果所表征的数据状态无法支撑后续的业务操作。更为具体一些：select 某记录是否存在，不存在，准备插入此记录，但执行 insert 时发现此记录已存在，无法插入，此时就发生了幻读 serializable ：效率最低 可避免幻读。读加共享锁，写加排他锁。这样读取事务可以并发，但是读写，写写事务之间都是互斥的，基本上就是一个个执行事务，所以叫序列化 ","date":"0001-01-01","objectID":"/2019.3.26_mysql%E4%BA%8B%E5%8A%A1%E7%AD%89%E7%BA%A7%E5%92%8C%E5%B9%BB%E8%AF%BB/:0:1","tags":null,"title":"MySql事务等级和幻读","uri":"/2019.3.26_mysql%E4%BA%8B%E5%8A%A1%E7%AD%89%E7%BA%A7%E5%92%8C%E5%B9%BB%E8%AF%BB/"},{"categories":null,"content":"查看当前事务等级 SELECT @@global.tx_isolation, @@tx_isolation; ","date":"0001-01-01","objectID":"/2019.3.26_mysql%E4%BA%8B%E5%8A%A1%E7%AD%89%E7%BA%A7%E5%92%8C%E5%B9%BB%E8%AF%BB/:0:2","tags":null,"title":"MySql事务等级和幻读","uri":"/2019.3.26_mysql%E4%BA%8B%E5%8A%A1%E7%AD%89%E7%BA%A7%E5%92%8C%E5%B9%BB%E8%AF%BB/"},{"categories":null,"content":"触发幻读 事前准备 create table t1 ( id int(10), age int(3), primary key(id) ) 触发过程 事务1 事务2 步骤 begin 1 select * from t1 where id =1 2 insert into t1 values (1,12) 3 insert into t1 values(1,12) 4 ​ 在事务1中，先查询有没有id = 1的记录，如果没有就插入，但是在查询后，事务2先插入了，那么事务1就出现错误 ","date":"0001-01-01","objectID":"/2019.3.26_mysql%E4%BA%8B%E5%8A%A1%E7%AD%89%E7%BA%A7%E5%92%8C%E5%B9%BB%E8%AF%BB/:0:3","tags":null,"title":"MySql事务等级和幻读","uri":"/2019.3.26_mysql%E4%BA%8B%E5%8A%A1%E7%AD%89%E7%BA%A7%E5%92%8C%E5%B9%BB%E8%AF%BB/"},{"categories":null,"content":"解决幻读 事务1 事务2 步骤 begin 1 select * from t1 where id =1 for update 2 insert into t1 values (1,12) 3 insert into t1 values(1,12) 4 commit 5 在Step2执行后，数据库会加一个X锁(排它锁)。这时Step3执行后，会一直等待事务1执行完毕，当事务1 commit后，事务2就报错了 ","date":"0001-01-01","objectID":"/2019.3.26_mysql%E4%BA%8B%E5%8A%A1%E7%AD%89%E7%BA%A7%E5%92%8C%E5%B9%BB%E8%AF%BB/:0:4","tags":null,"title":"MySql事务等级和幻读","uri":"/2019.3.26_mysql%E4%BA%8B%E5%8A%A1%E7%AD%89%E7%BA%A7%E5%92%8C%E5%B9%BB%E8%AF%BB/"},{"categories":null,"content":"关于页面","date":"0001-01-01","objectID":"/about/","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"手动阀 ","date":"0001-01-01","objectID":"/about/:0:0","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"归档","date":"0001-01-01","objectID":"/archives/","tags":null,"title":"归档","uri":"/archives/"}]