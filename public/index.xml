<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Zshell的博客</title>
    <link>https://blog.mcjy.top/</link>
    <description>Recent content on Zshell的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Wed, 04 Dec 2019 18:39:58 +0800</lastBuildDate>
    
	<atom:link href="https://blog.mcjy.top/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>当golang多个字段的json tag相同时会怎么样?</title>
      <link>https://blog.mcjy.top/post/2019.12.04_%E5%BD%93golang%E5%A4%9A%E4%B8%AA%E5%AD%97%E6%AE%B5%E7%9A%84json-tag%E7%9B%B8%E5%90%8C%E6%97%B6%E4%BC%9A%E6%80%8E%E4%B9%88%E6%A0%B7/</link>
      <pubDate>Wed, 04 Dec 2019 18:39:58 +0800</pubDate>
      
      <guid>https://blog.mcjy.top/post/2019.12.04_%E5%BD%93golang%E5%A4%9A%E4%B8%AA%E5%AD%97%E6%AE%B5%E7%9A%84json-tag%E7%9B%B8%E5%90%8C%E6%97%B6%E4%BC%9A%E6%80%8E%E4%B9%88%E6%A0%B7/</guid>
      <description>问题 今天我在写代码的时候遇到了标题所说的问题，我用google搜索了下也没有找到想要的答案。后来通过几个测试用例试了下这个发现问题有点意思
情况1 都是普通字段 type sameTag struct { A string `json:&amp;quot;a&amp;quot;` B string `json:&amp;quot;a&amp;quot;` Other string `json:&amp;quot;other&amp;quot;` } func TestSameJson(t *testing.</description>
    </item>
    
    <item>
      <title>MarshalJSON没有调用、无效？</title>
      <link>https://blog.mcjy.top/post/2019.11.08_marshaljson%E6%B2%A1%E6%9C%89%E8%B0%83%E7%94%A8%E6%97%A0%E6%95%88/</link>
      <pubDate>Fri, 08 Nov 2019 19:07:02 +0800</pubDate>
      
      <guid>https://blog.mcjy.top/post/2019.11.08_marshaljson%E6%B2%A1%E6%9C%89%E8%B0%83%E7%94%A8%E6%97%A0%E6%95%88/</guid>
      <description>问题 今天我在golang自定义json的序列化时，发现我的struct实现MarshalJSON()竟然没有效果，还是按照默认的方式来序列化。这让我非常郁闷☹，后来我查找了一些资料发现这个问题不简单。。
下面是我有问题的代码
type str string func (s *str) MarshalJSON() (data []byte, err error) { return json.</description>
    </item>
    
    <item>
      <title>上海办理护照流程</title>
      <link>https://blog.mcjy.top/post/2019.11.03_%E4%B8%8A%E6%B5%B7%E5%8A%9E%E7%90%86%E6%8A%A4%E7%85%A7%E6%B5%81%E7%A8%8B/</link>
      <pubDate>Sun, 03 Nov 2019 20:23:48 +0800</pubDate>
      
      <guid>https://blog.mcjy.top/post/2019.11.03_%E4%B8%8A%E6%B5%B7%E5%8A%9E%E7%90%86%E6%8A%A4%E7%85%A7%E6%B5%81%E7%A8%8B/</guid>
      <description>前言 我办理护照并不是因为目前有出过国的需求。而是国外的一些平台的身份认证需要上传护照，中国居民身份证在国外平台的认可度是没有护照高的。所以现在闲着没事办个护照，以备不时之需。
必要条件和证件 在上海办理护照要满足以下三个条件其中之一
 上海户籍 上海居住证 在上海连续缴纳一年社保  我就是以第三个条件来办理的护照</description>
    </item>
    
    <item>
      <title>当github action遇到element-ui-admin</title>
      <link>https://blog.mcjy.top/post/2019.10.21_%E5%BD%93github-action%E9%81%87%E5%88%B0element-ui-admin/</link>
      <pubDate>Mon, 21 Oct 2019 13:55:11 +0800</pubDate>
      
      <guid>https://blog.mcjy.top/post/2019.10.21_%E5%BD%93github-action%E9%81%87%E5%88%B0element-ui-admin/</guid>
      <description>Github Actions是github搞的一个持续集成服务,现在还在测试中,如果想要使用需要到官网去申请.
现在我想使用github actions实现vue-element-admin做的一个管理后台的自动构建发布到生产服务器的一系列过程
新建github workflow 进入github仓库的主页点击actions就可以创建一个新的workflow
新建文件的路径在仓库根目录的./github/workflows/
我之前误操作不知道为什么新建在仓库的根目录</description>
    </item>
    
    <item>
      <title>Linux常用命令</title>
      <link>https://blog.mcjy.top/post/2019.10.13_linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Sun, 13 Oct 2019 14:42:11 +0800</pubDate>
      
      <guid>https://blog.mcjy.top/post/2019.10.13_linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</guid>
      <description>zip命令 使用unzip的时候有时候想把文件解压到一个新的文件夹，如果直接写一个新目录会报错
在要解压的目的地的前面加个参数－d，就能新建一个不存的目录
mysql相关命令 自动补全 mysql的命令也是有自动补全的．需要的参数如下
mysql -u root -p --auto-rehash  开启后能自动补全了 但是这个只能补数据名和表名之类的，不能补全show databases 之类的命令，很蛋疼</description>
    </item>
    
    <item>
      <title>golang ldfalgs的小技巧</title>
      <link>https://blog.mcjy.top/post/2019.9.12_golang-ldfalgs%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7/</link>
      <pubDate>Mon, 26 Aug 2019 14:42:11 +0800</pubDate>
      
      <guid>https://blog.mcjy.top/post/2019.9.12_golang-ldfalgs%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7/</guid>
      <description>&lt;h2 id=&#34;问题&#34;&gt;问题&lt;/h2&gt;

&lt;p&gt;如果想要在go build生成的可执行文件中注入编译时间，git hash等信息。可以在编译的时候使用-ldflags -X参数来注入变量&lt;/p&gt;

&lt;p&gt;-ldfflags -X 可以在go install 、go build、go run  、go test中使用&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;go build -ldflags &amp;ldquo;-X  &amp;lsquo; packageName.varName=cmd &amp;rsquo; &amp;ldquo;&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Receiver has generic name</title>
      <link>https://blog.mcjy.top/post/2019.8.26_receiver-has-generic-name/</link>
      <pubDate>Mon, 26 Aug 2019 14:42:11 +0800</pubDate>
      
      <guid>https://blog.mcjy.top/post/2019.8.26_receiver-has-generic-name/</guid>
      <description>&lt;h4 id=&#34;问题&#34;&gt;问题&lt;/h4&gt;

&lt;p&gt;Golang的&lt;strong&gt;方法接收者&lt;/strong&gt;就是在函数名前的括号内的东西  如&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (self Car) run() // (self car)就是方法接收者
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在JetBrains系类的开发工具中（IntelliJ、Goland）如果方法接收者名字是&lt;strong&gt;self  me  this&lt;/strong&gt;类似的词，IDE会提示*Receiver has generic name*信息 如下图所示&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://s2.ax1x.com/2019/08/26/mW6QpQ.png&#34; alt=&#34;mW6QpQ.png&#34; /&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Systemd集成Golang程序</title>
      <link>https://blog.mcjy.top/post/2019.7.29_systemd%E9%9B%86%E6%88%90golang%E7%A8%8B%E5%BA%8F/</link>
      <pubDate>Mon, 29 Jul 2019 14:42:11 +0800</pubDate>
      
      <guid>https://blog.mcjy.top/post/2019.7.29_systemd%E9%9B%86%E6%88%90golang%E7%A8%8B%E5%BA%8F/</guid>
      <description>&lt;p&gt;当想要在服务器上部署一个常驻程序时，不想让程序随着Terminal的退出而中止，你可以使用docker nohup supervisor 这些工具来实现。但是处于想学习Linux中Systemd的目的，我使用Systemd来实现把一个Golang程序作为一个系统服务&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>golang time包相关的一些问题</title>
      <link>https://blog.mcjy.top/post/time%E5%8C%85%E7%9B%B8%E5%85%B3%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</link>
      <pubDate>Thu, 25 Jul 2019 14:42:11 +0800</pubDate>
      
      <guid>https://blog.mcjy.top/post/time%E5%8C%85%E7%9B%B8%E5%85%B3%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</guid>
      <description>&lt;h3 id=&#34;获取毫秒时间戳&#34;&gt;获取毫秒时间戳&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//第一种
time.Now().UnixNano() / int64(time.Millisecond)
//第二种
time.Now().UnixNano() / 1e6
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>MySql索引优化</title>
      <link>https://blog.mcjy.top/post/2019.3.25_mysql%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96/</link>
      <pubDate>Mon, 25 Mar 2019 14:42:11 +0800</pubDate>
      
      <guid>https://blog.mcjy.top/post/2019.3.25_mysql%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96/</guid>
      <description>MySql索引优化 语法 create table user_info ( id int AUTO_INCREMENT, name varchar(20), age int(3), email varchar(256), PRIMARY KEY (id) ); create index idx_user_nameAgeEmail on user_info (name,age,email); create table t ( a varchar(20), b int(3), c varchar(20) ); create index idx_a_b_c on t (a,b,c); create index &amp;lt;索引名称&amp;gt; on &amp;lt;表名&amp;gt; （&amp;lt;列名&amp;gt;,.</description>
    </item>
    
    <item>
      <title>使用idea自带的plugin反编译jar</title>
      <link>https://blog.mcjy.top/post/%E4%BD%BF%E7%94%A8idea%E8%87%AA%E5%B8%A6%E7%9A%84plugin%E5%8F%8D%E7%BC%96%E8%AF%91jar/</link>
      <pubDate>Mon, 25 Mar 2019 14:42:11 +0800</pubDate>
      
      <guid>https://blog.mcjy.top/post/%E4%BD%BF%E7%94%A8idea%E8%87%AA%E5%B8%A6%E7%9A%84plugin%E5%8F%8D%E7%BC%96%E8%AF%91jar/</guid>
      <description>问题 之前想反编译jar包,在网上了找了一些反编译的工具感觉都不太好用.就来我发现idea自带的反编译插件挺好用,但是没有GUI只能使用命令.
使用 这个插件在/plugins/java-decompiler/lib/java-decompiler.jar.这个jar不能直接用java -jar运行,这个jar没有只能main函数,直接java -jar会报错,下面是使用方法
java -cp java-decompiler.jar org.</description>
    </item>
    
    <item>
      <title>B-树的一些概念</title>
      <link>https://blog.mcjy.top/post/2019.3.21_b-%E6%A0%91%E7%9A%84%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5/</link>
      <pubDate>Thu, 21 Mar 2019 14:42:11 +0800</pubDate>
      
      <guid>https://blog.mcjy.top/post/2019.3.21_b-%E6%A0%91%E7%9A%84%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5/</guid>
      <description>&lt;h3 id=&#34;阶-的含义&#34;&gt;“阶”的含义&lt;/h3&gt;

&lt;p&gt;B-树的所有结点中&lt;strong&gt;最多可以拥有的子结点的个数&lt;/strong&gt;为“阶”，用M表示，下图是一个三阶B-树&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://imgchr.com/i/A3Ce7n&#34;&gt;&lt;img src=&#34;https://s2.ax1x.com/2019/03/21/A3Ce7n.png&#34; alt=&#34;A3Ce7n.png&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;三阶B树中所有节点的子节点最多有三个，不能超过三个&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>VoltDB入门</title>
      <link>https://blog.mcjy.top/post/2019.3.18_voltdb%E5%85%A5%E9%97%A8/</link>
      <pubDate>Mon, 18 Mar 2019 14:42:11 +0800</pubDate>
      
      <guid>https://blog.mcjy.top/post/2019.3.18_voltdb%E5%85%A5%E9%97%A8/</guid>
      <description>&lt;h1 id=&#34;安装运行&#34;&gt;安装运行&lt;/h1&gt;

&lt;h3 id=&#34;环境要求&#34;&gt;环境要求&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;python2.7以上，不支持python3&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;java8&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;安装&#34;&gt;安装&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;到官网注册个账号才能把下载链接发到邮箱，很蛋疼，不能直接下载&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;解压&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;把voltdb/bin/加入环境变量&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Ubuntu18.04 修改Mysql5.7默认root密码</title>
      <link>https://blog.mcjy.top/post/2019.3.16_ubuntu18.04-%E4%BF%AE%E6%94%B9mysql5.7%E9%BB%98%E8%AE%A4root%E5%AF%86%E7%A0%81/</link>
      <pubDate>Sat, 16 Mar 2019 14:42:11 +0800</pubDate>
      
      <guid>https://blog.mcjy.top/post/2019.3.16_ubuntu18.04-%E4%BF%AE%E6%94%B9mysql5.7%E9%BB%98%E8%AE%A4root%E5%AF%86%E7%A0%81/</guid>
      <description>&lt;h4 id=&#34;步骤&#34;&gt;步骤&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;设置mysql免密码登陆
编辑/etc/mysql/my.cnf文件,在最后加入以下设置&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-aidl&#34;&gt;[mysqld]
skip-grant-tables=1
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;重启mysql&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-aidl&#34;&gt;$ sudo service mysql stop
$ sudo service mysql strat
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>WSL安装和使用LxRunOffline备份</title>
      <link>https://blog.mcjy.top/post/2019.3.16_wsl%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8lxrunoffline%E5%A4%87%E4%BB%BD/</link>
      <pubDate>Sat, 16 Mar 2019 14:42:11 +0800</pubDate>
      
      <guid>https://blog.mcjy.top/post/2019.3.16_wsl%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8lxrunoffline%E5%A4%87%E4%BB%BD/</guid>
      <description>&lt;h1 id=&#34;安装&#34;&gt;安装&lt;/h1&gt;

&lt;h3 id=&#34;开启wsl组件&#34;&gt;开启WSL组件&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;  Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;下载镜像&#34;&gt;下载镜像&lt;/h3&gt;

&lt;p&gt;由于我的Win10是精简版所以没用应用商店所以只能手动下载镜像&lt;/p&gt;

&lt;p&gt;各个发行版 &lt;a href=&#34;https://docs.microsoft.com/en-us/windows/wsl/install-manua&#34;&gt;https://docs.microsoft.com/en-us/windows/wsl/install-manua&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title></title>
      <link>https://blog.mcjy.top/about/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.mcjy.top/about/</guid>
      <description>士大夫大师傅</description>
    </item>
    
    <item>
      <title>MySql事务等级和幻读</title>
      <link>https://blog.mcjy.top/post/2019.3.26_mysql%E4%BA%8B%E5%8A%A1%E7%AD%89%E7%BA%A7%E5%92%8C%E5%B9%BB%E8%AF%BB/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.mcjy.top/post/2019.3.26_mysql%E4%BA%8B%E5%8A%A1%E7%AD%89%E7%BA%A7%E5%92%8C%E5%B9%BB%E8%AF%BB/</guid>
      <description>&lt;h3 id=&#34;四个事物等级&#34;&gt;四个事物等级&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;read uncommitted ：有可能脏读&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一个事务过程中读取到了，另一个事务的中途数据&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;read committed ：有可能不可重复读&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;即在一次事务之间，进行了两次读取，但是结果不一样，可能第一次id为1的人叫“李三”，第二次读id为1的人就叫了“李四”。因为读取操作不会阻止其他事务&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;repetable read ：有可能幻读&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;幻读侧重的方面是某一次的 select 操作得到的结果所表征的数据状态无法支撑后续的业务操作。更为具体一些：select 某记录是否存在，不存在，准备插入此记录，但执行 insert 时发现此记录已存在，无法插入，此时就发生了幻读&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;serializable ：效率最低&lt;/p&gt;

&lt;p&gt;可避免幻读。读加共享锁，写加排他锁。这样读取事务可以并发，但是读写，写写事务之间都是互斥的，基本上就是一个个执行事务，所以叫序列化&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>关于</title>
      <link>https://blog.mcjy.top/about/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.mcjy.top/about/</guid>
      <description>手动阀</description>
    </item>
    
    <item>
      <title>归档</title>
      <link>https://blog.mcjy.top/archives/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.mcjy.top/archives/</guid>
      <description></description>
    </item>
    
  </channel>
</rss>